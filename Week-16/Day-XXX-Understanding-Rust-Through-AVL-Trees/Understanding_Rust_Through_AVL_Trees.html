<!DOCTYPE html>
<!-- saved from url=(0081)https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>
    
    Understanding Rust Through AVL Trees
    
  </title>
  <meta name="description" content="From&lt;Elixir&gt;, Into&lt;Rust&gt;I loved learning the Elixir language and how its pragmatic supervisiontrees and process model taught me the value fault t...">
  <link rel="stylesheet" href="./Understanding_Rust_Through_AVL_Trees_files/css">
  <link rel="stylesheet" href="./Understanding_Rust_Through_AVL_Trees_files/main.css">
  <link rel="canonical" href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/">
  <link rel="alternate" type="application/rss+xml" title="Fn/Log" href="https://francismurillo.github.io/feed.xml">
  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Understanding Rust Through AVL Trees | Fn/Log</title>
<meta name="generator" content="Jekyll v3.8.5">
<meta property="og:title" content="Understanding Rust Through AVL Trees">
<meta name="author" content="Francis Murillo">
<meta property="og:locale" content="en_US">
<meta name="description" content="From&lt;Elixir&gt;, Into&lt;Rust&gt; I loved learning the Elixir language and how its pragmatic supervision trees and process model taught me the value fault tolerance as a quality of code than of infrastructure. Having safety and failure recovery as an idiomatic culture and mindset of the language made me a better thinker and developer. As a personal preference then in selecting new languages to learn, I look for potentially new perspectives and insights that it ascribes to its pilgrims. In general, a good learning curve is a good indicator since it has much to teach.">
<meta property="og:description" content="From&lt;Elixir&gt;, Into&lt;Rust&gt; I loved learning the Elixir language and how its pragmatic supervision trees and process model taught me the value fault tolerance as a quality of code than of infrastructure. Having safety and failure recovery as an idiomatic culture and mindset of the language made me a better thinker and developer. As a personal preference then in selecting new languages to learn, I look for potentially new perspectives and insights that it ascribes to its pilgrims. In general, a good learning curve is a good indicator since it has much to teach.">
<link rel="canonical" href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/">
<meta property="og:url" content="//francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/">
<meta property="og:site_name" content="Fn/Log">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-07-31T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Understanding Rust Through AVL Trees">
<meta name="twitter:site" content="@FVMurillo">
<meta name="twitter:creator" content="@Francis Murillo">
<script type="application/ld+json">
{"datePublished":"2019-07-31T00:00:00+00:00","description":"From&lt;Elixir&gt;, Into&lt;Rust&gt; I loved learning the Elixir language and how its pragmatic supervision trees and process model taught me the value fault tolerance as a quality of code than of infrastructure. Having safety and failure recovery as an idiomatic culture and mindset of the language made me a better thinker and developer. As a personal preference then in selecting new languages to learn, I look for potentially new perspectives and insights that it ascribes to its pilgrims. In general, a good learning curve is a good indicator since it has much to teach.","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"//francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/"},"url":"//francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/","author":{"@type":"Person","name":"Francis Murillo"},"headline":"Understanding Rust Through AVL Trees","dateModified":"2019-07-31T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>

  <body>
    <div class="row header-line">
    <div class="header-separator header-separator-site">
    </div>
    <div class="row header-segment header-line-site">
        <a href="https://francismurillo.github.io/">
            % Fn/Log
        </a>
    </div>
    <div class="header-inner-separator header-separator-site-category">
    </div>
    <div class="row header-segment header-line-category">
        
        <a href="https://francismurillo.github.io/hacker">
            
            Hacker
            
        </a>
        
    </div>
    <div class="header-inner-separator header-separator-category-title">
    </div>
    <div class="row header-segment header-line-title">
        <span>
            
            Understanding rust through avl trees
            
        </span>
    </div>
    <div class="header-separator header-separator-title">
    </div>
</div>

    <div class="page-content">
      <div class="wrapper">
        

        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
    <div class="post-content" itemprop="articleBody">
        <div id="outline-container-orgc392d10" class="outline-2">
<h2 id="orgc392d10">From&lt;Elixir&gt;, Into&lt;Rust&gt;</h2>
<div class="outline-text-2" id="text-orgc392d10">
<p>
I loved learning the <a href="https://elixir-lang.org/">Elixir</a> language and how its pragmatic <a href="https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html">supervision
trees</a> and <a href="https://elixir-lang.org/getting-started/processes.html">process model</a> taught me the value <a href="https://en.wikipedia.org/wiki/Fault_tolerance">fault tolerance</a> as a
quality of code than of infrastructure. Having safety and failure
recovery as an idiomatic culture and mindset of the language made me a
better thinker and developer. As a personal preference then in
selecting new languages to learn, I look for potentially new
perspectives and insights that it ascribes to its pilgrims. In
general, a good learning curve is a good indicator since it has much
to teach.
</p>

<p>
Another language to learn that I believe is worth learning is <a href="https://www.rust-lang.org/">Rust</a>, a
system programming language with a strong culture of memory safety.
Its pervasive model of <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html">ownership and lifetimes</a> alongside its demanding
yet helpful compiler makes compiling code both a challenge and thrill.
Aside from the higher learning curve, the absence of a garbage
collector and virtual machine while proclaiming safety and performance
in the face of concurrency is boldly insane. If I do invest, I expect
to be more acute about memory issues and be more confident with
algorithms.
</p>

<p>
After reading the <a href="https://doc.rust-lang.org/book/">main online book</a>, the best way to understand a
language for me is by writing code with a project. Since <i>Rust</i> is a
safe alternative to the <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> language, I want to revisit the data
structures and algorithms that I avoided because of tricky pointer
management. In starting with <a href="https://en.wikipedia.org/wiki/Linked_list">linked lists</a>, I stumbled across <a href="https://rust-unofficial.github.io/too-many-lists/">Too Many
Linked List online book</a> which was godsend. Reading it next, I want to
step it up and implement a tricky data structure that had interesting
mechanics to prove my understanding: <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL Trees</a>.
</p>

<p>
To understand my intent to go back to the basics, I scoffed at <i>C</i> for
being too unsafe relative to <a href="https://www.java.com/en/">Java</a>'s automatic memory management during
my teenage years. What foolish thoughts. Nonetheless, it pushed me
away from learning lower level algorithms which I thought of a hole in
my knowledge for years. With this regret, I ran <code>cargo new --lib
  avl_tree_set_rs</code>.
</p>

<p>
After three weeks of struggling and tangents, I successfully wrote it
with green tests. I found my trial a rigorous yet enlightening
learning experience. Despite all the resistance and confusion from the
compiler, I trust that as long as it compiles, my code and more
importantly I feel safe, a similar feeling in <a href="https://www.haskell.org/">Haskell</a>. In this
article, indulge me in my experience of implementing a self-balancing
binary tree in <i>Rust</i> as a learning project. Hopefully, this is worth
your time, helpful or entertaining. So what does it take to implement
an <i>AVL Tree</i> in <i>Rust</i>?
</p>

<p>
(Source code for this article can be found <a href="https://github.com/FrancisMurillo/avl_tree_set_rs">here</a>.)
</p>

<p>
<b>REQUIREMENT:</b>: This article assumes a <code>rustc</code> version of at least
<code>1.38</code> for the <a href="https://github.com/rust-lang/rfcs/blob/master/text/2094-nll.md">non-lexical lifetimes</a> if you want to compile or follow
the code.
</p>

<p>
<b>CAVEAT:</b> This is not a tutorial on Rust. I assume you have read the
book yourself and somewhat familiar with binary trees or sets.
Although my writing may not be technically precise, I want to focus on
discussing <i>Rust</i> from a newcomer's perspective. I do my best to link
relevant sections from the book to help me explain syntax and
concepts, so do visit them if you need to refresh yourself. You can
also try running <code>rustup doc --std</code> that opens a local copy of the
standard documentation. I found it quite helpful and convenient in
understanding functions and methods. If I make any incriminating
errors in terminology or code, do file an issue in the article's
<a href="https://github.com/FrancisMurillo/avl_tree_set_rs/issues">repository</a>, so we can rectify it and my thanks.
</p>

<ul class="org-ul">
<li><a href="https://github.com/FrancisMurillo/avl_tree_set_rs/issues?q=is%3Aopen+is%3Aissue+label%3Aarticle">Corrections</a></li>
</ul>

<p>
<b>UPDATE 2019-12-18:</b> Credits to <b><b>jbj</b></b> for filing a <a href="https://github.com/FrancisMurillo/avl_tree_set_rs/pull/3">PR</a> in rewriting
<code>take</code> and <code>insert</code> without using <code>unsafe</code> by using recursion.
</p>
</div>
</div>

<div id="outline-container-orge5755b0" class="outline-2">
<h2 id="orge5755b0">AVL Trees</h2>
<div class="outline-text-2" id="text-orge5755b0">
<p>
As a short discussion, <a href="https://en.wikipedia.org/wiki/Binary_search_tree">ordered binary trees</a> are good at searching
values. As more values expand the tree, it becomes less efficient
proportional to its height. Thus, rearranging nodes that minimize
height maintains lookup efficiency.
</p>

<p>
<img src="./Understanding_Rust_Through_AVL_Trees_files/avl-trees--binary-trees.png" alt="Visualization of Binary Trees">
</p>

<p>
To answer that issue, <b>self-balancing trees</b> balance themselves after
every node insertion and deletion. Different variants such
<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Black-Red
Trees</a>, <a href="https://en.wikipedia.org/wiki/Splay_tree">Splay Trees</a> and <a href="https://en.wikipedia.org/wiki/B-tree">B-Trees</a> are available each with their own
strategy. I choose <i>AVL trees</i> for its conceptually simple left and
right rotations as its balancing strategy while proving a challenge in
<i>Rust</i> because of the pointers that dance in those rotations.
</p>

<p>
Implementing recursive data structures like trees and graphs in <i>Rust</i>
are not trivial because of its <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html?highlight=stack,vs,hea#the-stack-and-the-heap">ownership model</a> and potential
<a href="https://en.wikipedia.org/wiki/Circular_reference">circular
references</a>. Specially in insertion and deletion, swapping nodes and
values safely and correctly while obeying the rules is tricky itself.
Aside from those and some mangling of lifetime variables, we have a
modern <i>C</i> language with familiar functional programming concepts at
our disposal . Despite the uncertainty, tackling this classic
structure with modern ideas makes it feel approachable.
</p>

<p>
For this project, we will build our <i>AVL tree</i> as a <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">set</a>. To understand
idiomatic language design, we will follow and implement methods from
the ordered tree set of the standard collection:
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">std::collections::BTreeSet</a>. As much as I would implement every
relevant method, the focus of this article is inserting and deleting
values from our set that we will discuss in three major sections:
<b>insertion</b>, <b>balancing</b> and <b>deletion</b>.
</p>

<p>
Since this article is long, feel free to stop and come back anytime.
Below are links to major sections each with their own links to
their subsections:
</p>

<ul class="org-ul">
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orgb7a42c9">Insertion</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org67ca508">Rebalancing</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org751b358">Deletion</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org48d7f72">Beyond Parity</a> (<i>Optional</i>)</li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orgaa91b9a">Reflecting On Rust</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb7a42c9" class="outline-2">
<h2 id="orgb7a42c9">Insertion</h2>
<div class="outline-text-2" id="text-orgb7a42c9">
<p>
To begin our journey, we will implement the insertion (<code>.insert</code>)
method to populate our set and test the values with an iterator
(<code>.iter</code>) method. Since implementing balancing strategy is challenging
upfront, we will implement it after this to have a working feedback
cycle and momentum.
</p>

<ul class="org-ul">
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orgea9b4b4">Data Types</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orga1ff405">Insert Method</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orgdc4450a">Iterator</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org0d52e2b">Testing Insert</a></li>
</ul>
</div>

<div id="outline-container-orgea9b4b4" class="outline-3">
<h3 id="orgea9b4b4">Data Types</h3>
<div class="outline-text-3" id="text-orgea9b4b4">
<p>
What is the design of our tree structure? With some hint from <a href="https://rust-unofficial.github.io/too-many-lists/second-option.html">this
chapter</a>, we will use a recursive tree design:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">derive</span><span style="color: #ff1493;">(</span><span style="color: #96a5d9;">Debug, PartialEq, Clone</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">struct</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span><span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #ff694d;">value</span>: <span style="color: #f5b55f;">T</span>,
    <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,
    <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9; font-weight: bold;">type</span> <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> = <span style="color: #f5b55f;">Option</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">Box</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">&gt;</span>; <span style="color: #2872b2;">// </span><span style="color: #2872b2;">What is Box?</span>

<span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">derive</span><span style="color: #ff1493;">(</span><span style="color: #96a5d9;">Debug, PartialEq, Clone</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">struct</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #ff694d;">root</span>: <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span><span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">new</span><span style="color: #ff1493;">()</span> -&gt; <span style="color: #f5b55f;">Self</span> <span style="color: #ff1493;">{</span>
        <span style="color: #f5b55f;">Self</span> <span style="color: #7fff00;">{</span> <span style="color: #ff694d;">root</span>: <span style="color: #f5b55f;">None</span> <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
To explain some <i>Rust</i> specific details, our set library must take
any value that can be ordered, so we declare a <a href="https://doc.rust-lang.org/book/ch10-00-generics.html">generic type</a> that
implements the ordering (<a href="https://doc.rust-lang.org/std/cmp/index.html">std::cmp::Ord</a>) trait (<code>T: Ord</code>). The main
<a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html?highlight=struct#defining-and-instantiating-structs">struct</a> <code>AvlNode</code> expresses a binary tree node that stores a value and
possibly has a left and right subtree where the child value is less
than and greater than respectively this node's stored value. The
<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html?highlight=Aliasing#creating-type-synonyms-with-type-aliases">newtype/type alias</a> <code>AvlTree</code> represents either an empty value/tree or
a node which completes the recursive definition by using the
<a href="https://doc.rust-lang.org/std/option/index.html">std::option::Option</a> type. Finally, <code>AvlTreeSet</code> provides the
interface over the underlying data structure. Optionally, we also
<a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html?highlight=derive#appendix-c-derivable-traits">derive</a> some useful traits such as debugging via <code>dbg!</code>
(<a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html">std::fmt::Debug</a>), allow equality checks <code>==</code> (<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">std::cmp::PartialEq</a>)
and cloning capabilities for testing with <code>.clone</code>
(<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">std::clone::Clone)</a>.
</p>

<p>
This design is similar in other languages like <a href="https://wiki.haskell.org/99_questions/54A_to_60">Haskell</a> and <a href="https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html">Java</a>, so
we have not strayed far from the path. The snippet below shows how to
initialize this:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">tree</span> = <span style="color: #f5b55f;">Some</span><span style="color: #ff8c00;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #ff1493;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #7fff00;">{</span>
    <span style="color: #ff694d;">value</span>: 2,
    <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">Some</span><span style="color: #00bfff;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #ffff00;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #da70d6;">{</span>
        <span style="color: #ff694d;">value</span>: 1,
        <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">None</span>,
        <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">None</span>,
    <span style="color: #da70d6;">}</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span>,
    <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">Some</span><span style="color: #00bfff;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #ffff00;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #da70d6;">{</span>
        <span style="color: #ff694d;">value</span>: 5,
        <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">Some</span><span style="color: #00ff7f;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #ff8247;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #9cb6ad;">{</span>
            <span style="color: #ff694d;">value</span>: 3,
            <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">None</span>,
            <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">Some</span><span style="color: #ff8c00;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #ff1493;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #7fff00;">{</span>
                <span style="color: #ff694d;">value</span>: 4,
                <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">None</span>,
                <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">None</span>,
            <span style="color: #7fff00;">}</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>,
        <span style="color: #9cb6ad;">}</span><span style="color: #ff8247;">)</span><span style="color: #00ff7f;">)</span>,
        <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">None</span>,
    <span style="color: #da70d6;">}</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span>,
<span style="color: #7fff00;">}</span><span style="color: #ff1493;">)</span>;
</pre>
</div>

<p>
As cumbersome it is to initialize, we encounter our first memory
design consideration for recursive structures: <a href="https://doc.rust-lang.org/std/boxed/index.html">std::boxed::Box</a>.
Generally, structs or data types should have a <a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">known or constant size</a>
for memory allocation. Every primitive type has a <a href="https://doc.rust-lang.org/std/mem/fn.size_of.html">fixed size</a> such as
<code>1</code> byte for <code>bool</code> and <code>u8</code> and <code>4</code> bytes for <code>i32</code> or <code>char</code>. While
complex structures can be thought of as a <a href="https://doc.rust-lang.org/std/mem/fn.size_of.html#size-of-structs">sum of its parts</a>, the
compiler cannot infer the known size for recursive structure at
compile time since the size is proportional to the level of nesting
required at runtime. To resolve this constant and dynamic memory
conundrum, since references and pointers also have the <a href="https://doc.rust-lang.org/std/mem/fn.size_of.html">same and fixed
size</a>, we wrap the recursive data with a <a href="https://doc.rust-lang.org/book/ch15-00-smart-pointers.html?highlight=fat,pointer#smart-pointers">heap allocated pointer</a> which
stores and points to the data in the heap that <a href="https://doc.rust-lang.org/alloc/#boxed-values">satisfies the size
constraint</a> and why we wrap each child node with <code>Box::new</code>.
</p>

<p>
This is unlike other languages where you could use the types without
such consideration. Initially awkward, I find it fascinating that
<i>Rust</i> requires some forethought to also think about how data is
stored (<a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html?highlight=stack,vs,hea#the-stack-and-the-heap">Stack or Heap</a>) at a safe and high level. That this enforced
compiler discipline gives me the impression that code in this
language is more likely to be planned and deliberate. Definitions
done, we proceed with the main method.
</p>
</div>
</div>

<div id="outline-container-orga1ff405" class="outline-3">
<h3 id="orga1ff405">Insert Method</h3>
<div class="outline-text-3" id="text-orga1ff405">
<p>
<b>Parity:</b> <a href="https://doc.rust-lang.org/std/collections/btree_set/struct.BTreeSet.html#method.insert">BTreeSet::insert</a>
</p>

<p>
To insert new values our tree set, we follow a standard procedure for
binary trees:
</p>

<ol class="org-ol">
<li>Starting from the root node or with a current node</li>
<li>Move to the left node if the value is less than the current node,
right if greater, and stop if equal</li>
<li>Do this until you an empty node and insert the value</li>
</ol>

<p>
Translating this into <i>Rust</i>:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">std</span>::<span style="color: #afc0fd; font-weight: bold;">cmp</span>::<span style="color: #f5b55f;">Ordering</span>;

<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span><span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">insert</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>, <span style="color: #ff694d;">value</span>: <span style="color: #f5b55f;">T</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">current_tree</span> = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.root;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1. Starting from the root node or with a current node</span>
        <span style="color: #96a5d9; font-weight: bold;">while</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span>current_node<span style="color: #7fff00;">)</span> = current_tree <span style="color: #7fff00;">{</span>
            <span style="color: #2872b2;">// </span><span style="color: #2872b2;">2. Move to the left node if the value is less than the current node,</span>
            <span style="color: #2872b2;">//    </span><span style="color: #2872b2;">right if greater, and stop if equal</span>
            <span style="color: #96a5d9; font-weight: bold;">match</span> current_node.value.cmp<span style="color: #00bfff;">(</span>&amp;value<span style="color: #00bfff;">)</span> <span style="color: #00bfff;">{</span>
                <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Less</span> =&gt; current_tree = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> current_node.right,
                <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Equal</span> =&gt; <span style="color: #ffff00;">{</span>
                    <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #96a5d9; font-weight: bold;">false</span>;
                <span style="color: #ffff00;">}</span>
                <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Greater</span> =&gt; current_tree = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> current_node.left,
            <span style="color: #00bfff;">}</span>
        <span style="color: #7fff00;">}</span>

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">3. Do this until you an empty node and insert the value</span>
        *current_tree = <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #00bfff;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #ffff00;">{</span>
            value,
            <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">None</span>,
            <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">None</span>,
        <span style="color: #ffff00;">}</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>;

        <span style="color: #96a5d9; font-weight: bold;">true</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
With <a href="https://doc.rust-lang.org/book/ch18-01-all-the-places-for-patterns.html?highlight=pattern,mat#while-let-conditional-loops">pattern matching</a>, it is easily done and also handles the empty
tree case. The snippet below shows how to use it:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = <span style="color: #f5b55f;">AvlTreeSet</span>::new<span style="color: #ff8c00;">()</span>;

<span style="color: #96a5d9;">assert!</span><span style="color: #ff8c00;">(</span>set.insert<span style="color: #ff1493;">(</span>1<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>;   <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Insert new value</span>
<span style="color: #96a5d9;">assert!</span><span style="color: #ff8c00;">(</span>!set.insert<span style="color: #ff1493;">(</span>1<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>;  <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Should not insert existing value</span>

<span style="color: #96a5d9;">assert!</span><span style="color: #ff8c00;">(</span>set.insert<span style="color: #ff1493;">(</span>2<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>;   <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Insert another new value</span>
<span style="color: #96a5d9;">assert_eq!</span><span style="color: #ff8c00;">(</span>               <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Checking the tree structure</span>
    set.root,
    <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #7fff00;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #00bfff;">{</span>
        <span style="color: #ff694d;">value</span>: 1,
        <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">None</span>,
        <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">Some</span><span style="color: #ffff00;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #da70d6;">(</span><span style="color: #f5b55f;">AvlNode</span> <span style="color: #00ff7f;">{</span>
            <span style="color: #ff694d;">value</span>: 2,
            <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">None</span>,
            <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">None</span>
        <span style="color: #00ff7f;">}</span><span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span>,
    <span style="color: #00bfff;">}</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">)</span>;
</pre>
</div>

<p>
How do we test <code>.insert</code>? We could implement <a href="https://doc.rust-lang.org/std/collections/btree_set/struct.BTreeSet.html#method.contains">BTreeSet::contains</a> to
test if the inserted value is present; however, where it is inserted
also matters. If the node is inserted in the left instead of the
right, the order of the set would be incorrect. So we need to test it
structurally, and we can do that with an <a href="https://en.wikipedia.org/wiki/Iterator">tree iterator</a> which we will
implement next.
</p>
</div>
</div>

<div id="outline-container-orgdc4450a" class="outline-3">
<h3 id="orgdc4450a">Iterator</h3>
<div class="outline-text-3" id="text-orgdc4450a">
<p>
<b>Parity:</b> <a href="https://doc.rust-lang.org/std/collections/btree_set/struct.BTreeSet.html#method.iter">BTreeSet::iter</a>
</p>

<p>
For our ordered set, we want the iterator to process the data in
ascending order, so we will use an <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)">in-order traversal</a> or
left-node-right approach. Since this is lower level language, we are
using a loop instead of a recursive function to express the
algorithm:
</p>

<ol class="org-ol">
<li>Starting from the root node or with a current node</li>
<li>If the node has a left subtree, store this node in a stack of
unemitted nodes, then move to the left node and repeat this step</li>
<li>Otherwise, emit the value</li>
<li>Next if the node has a right subtree, then move to the right node
and repeat from step 2</li>
<li>If neither and there is an unemitted node in the stack, pop that
and emit that node's value and repeat step 3 with that right node</li>
<li>If no more unemitted nodes remain, stop</li>
</ol>

<p>
The common pattern is to implement a <code>.iter</code> method that will return
a struct that implements <a href="https://doc.rust-lang.org/std/iter/index.html#implementing-iterator">std::iter::Iterator</a> and emits references to
the underlying tree. Before working on the code, we need to define
the struct to hold the iterator state that holds the previously
traversed nodes and the current tree:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">derive</span><span style="color: #ff1493;">(</span><span style="color: #96a5d9;">Debug</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">struct</span> <span style="color: #f5b55f;">AvlTreeSetIter</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #ff694d;">prev_nodes</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span>,
    <span style="color: #ff694d;">current_tree</span>: &amp;'<span style="color: #ff694d;">a</span> <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">Iterator</span> <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #f5b55f;">AvlTreeSetIter</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">type</span> <span style="color: #f5b55f;">Item</span> = &amp;'<span style="color: #ff694d;">a</span> <span style="color: #f5b55f;">T</span>;

    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">next</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">Option</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Self</span>::<span style="color: #f5b55f;">Item</span><span style="color: #ff1493;">&gt;</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9;">unimplemented!</span><span style="color: #7fff00;">()</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>

<span style="color: #2872b2;">// </span><span style="color: #2872b2;">Addition of lifetime parameter for the set</span>
<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">iter</span><span style="color: #ff1493;">(</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">AvlTreeSetIter</span><span style="color: #ff1493;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span> <span style="color: #ff1493;">{</span>
        <span style="color: #f5b55f;">AvlTreeSetIter</span> <span style="color: #7fff00;">{</span>
            <span style="color: #ff694d;">prev_nodes</span>: <span style="color: #f5b55f;">Vec</span>::new<span style="color: #00bfff;">()</span>,
            <span style="color: #ff694d;">current_tree</span>: &amp;<span style="color: #96a5d9; font-weight: bold;">self</span>.root,
        <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Aside from treating <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push">std::vec::Vec</a> as a stack, we need to discuss
<a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html?highlight=lifetime#lifetime-annotation-syntax">lifetime for parameters</a>. This is one of <i>Rust</i> concepts that is
conceptually easy but understanding the syntax requires practice.
Fundamentally, every reference has a lifetime scope before being
dropped that must not outlive the owner to avoid dangling
references. Our iterator will not mutate or acquire ownership of the
tree, instead it needs a reference to traverse it and that the
iterator lives as long as the set itself. We express this by
introducing a lifetime parameter(<code>'a</code>) on each struct that is
connected through the <code>.iter</code>. We also specify that emitted reference
values also live as long as the iterator itself through the
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">associated type</a> (<code>Item</code>). Even with all this extra typing for
lifetimes, the compiler is quite helpful in ensuring that the
iterator safely references the set.
</p>

<p>
Another interesting discipline of <i>Rust</i> in thinking about the
lifetime requirements of references as part of the design. My
personal learning experience is to add explicit annotation for each
reference, figure out their scope and then remove it if unnecessary
as with <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html?highlight=Eli#lifetime-elision">lifetime elision</a>. As much as possible, I let the Rust
compiler infer as much and stepping in when needed.
</p>

<p>
Going back, when implementing <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html?highlight=stack,vs,hea#the-stack-and-the-heap">Iterator::next</a> method, we return
<code>Some(value)</code> when we want to emit <code>value</code> and return <code>None</code> if we
have no more. With this in mind, we can proceed:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">next</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">Option</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">Self</span>::<span style="color: #f5b55f;">Item</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">loop</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">match</span> *<span style="color: #96a5d9; font-weight: bold;">self</span>.current_tree <span style="color: #7fff00;">{</span>
            <span style="color: #f5b55f;">None</span> =&gt; <span style="color: #96a5d9; font-weight: bold;">match</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.prev_nodes.pop<span style="color: #00bfff;">()</span> <span style="color: #00bfff;">{</span>
                <span style="color: #f5b55f;">None</span> =&gt; <span style="color: #ffff00;">{</span>
                    <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">None</span>;
                <span style="color: #ffff00;">}</span>

                <span style="color: #f5b55f;">Some</span><span style="color: #ffff00;">(</span><span style="color: #96a5d9; font-weight: bold;">ref</span> <span style="color: #ff694d;">prev_node</span><span style="color: #ffff00;">)</span> =&gt; <span style="color: #ffff00;">{</span>
                    <span style="color: #96a5d9; font-weight: bold;">self</span>.current_tree = &amp;prev_node.right;

                    <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">Some</span><span style="color: #da70d6;">(</span>&amp;prev_node.value<span style="color: #da70d6;">)</span>;
                <span style="color: #ffff00;">}</span>
            <span style="color: #00bfff;">}</span>,

            <span style="color: #f5b55f;">Some</span><span style="color: #00bfff;">(</span><span style="color: #96a5d9; font-weight: bold;">ref</span> <span style="color: #ff694d;">current_node</span><span style="color: #00bfff;">)</span> =&gt; <span style="color: #00bfff;">{</span>
                <span style="color: #96a5d9; font-weight: bold;">if</span> current_node.left.is_some<span style="color: #ffff00;">()</span> <span style="color: #ffff00;">{</span>
                    <span style="color: #96a5d9; font-weight: bold;">self</span>.prev_nodes.push<span style="color: #da70d6;">(</span>&amp;current_node<span style="color: #da70d6;">)</span>;
                    <span style="color: #96a5d9; font-weight: bold;">self</span>.current_tree = &amp;current_node.left;

                    <span style="color: #96a5d9; font-weight: bold;">continue</span>;
                <span style="color: #ffff00;">}</span>

                <span style="color: #96a5d9; font-weight: bold;">if</span> current_node.right.is_some<span style="color: #ffff00;">()</span> <span style="color: #ffff00;">{</span>
                    <span style="color: #96a5d9; font-weight: bold;">self</span>.current_tree = &amp;current_node.right;

                    <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">Some</span><span style="color: #da70d6;">(</span>&amp;current_node.value<span style="color: #da70d6;">)</span>;
                <span style="color: #ffff00;">}</span>

                <span style="color: #96a5d9; font-weight: bold;">self</span>.current_tree = &amp;<span style="color: #f5b55f;">None</span>;

                <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">Some</span><span style="color: #ffff00;">(</span>&amp;current_node.value<span style="color: #ffff00;">)</span>;
            <span style="color: #00bfff;">}</span>
        <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Although a bit longer, it just requires a little work. One thing I
find interesting here is that pattern matching also has move
semantics via <a href="https://doc.rust-lang.org/std/keyword.ref.html">ref</a> keyword. Quite intriguing where borrow mechanics
pervade even the familiar pattern matching. To show our code works,
we insert a range backwards (<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.rev">Iterator::rev</a>) and expect it to come up
in ascending order:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = <span style="color: #f5b55f;">AvlTreeSet</span>::new<span style="color: #ff8c00;">()</span>;

<span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">i</span> <span style="color: #96a5d9; font-weight: bold;">in</span> <span style="color: #ff8c00;">(</span>1..4 <span style="color: #96a5d9; font-weight: bold;">as</span> <span style="color: #f5b55f;">usize</span><span style="color: #ff8c00;">)</span>.rev<span style="color: #ff8c00;">()</span> <span style="color: #ff8c00;">{</span>
    set.insert<span style="color: #ff1493;">(</span>i<span style="color: #ff1493;">)</span>;
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">iter</span> = set.iter<span style="color: #ff8c00;">()</span>;
<span style="color: #96a5d9;">assert_eq!</span><span style="color: #ff8c00;">(</span>iter.next<span style="color: #ff1493;">()</span>, <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>&amp;1<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>;
<span style="color: #96a5d9;">assert_eq!</span><span style="color: #ff8c00;">(</span>iter.next<span style="color: #ff1493;">()</span>, <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>&amp;2<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>;
<span style="color: #96a5d9;">assert_eq!</span><span style="color: #ff8c00;">(</span>iter.next<span style="color: #ff1493;">()</span>, <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>&amp;3<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>;
<span style="color: #96a5d9;">assert_eq!</span><span style="color: #ff8c00;">(</span>iter.next<span style="color: #ff1493;">()</span>, <span style="color: #f5b55f;">None</span><span style="color: #ff8c00;">)</span>;
</pre>
</div>

<p>
Can we test <code>.iter</code> without <code>.insert</code>? If we create a different
constructor for our set that takes a collection or iterator and build
nodes around it, we certainly could; however, it requires that we
arrange them in a balanced manner which is beyond our current
capacity. Testing both <code>.iter</code> and <code>.insert</code> is the simplest way to
go.
</p>
</div>
</div>

<div id="outline-container-org0d52e2b" class="outline-3">
<h3 id="org0d52e2b">Testing Insert</h3>
<div class="outline-text-3" id="text-org0d52e2b">
<p>
To test <code>.iter</code> and <code>.insert</code> together, we do the following:
</p>

<ol class="org-ol">
<li>Create a random list</li>
<li>Create an empty AVL tree and BTree</li>
<li>For each element in the list, insert it to both tree</li>
<li>Both AVL and BTree iterator should be equal item per item</li>
</ol>

<p>
For generating random data, we will use <a href="https://github.com/BurntSushi/quickcheck">quickcheck</a> as a generator and
our testing style: <a href="https://begriffs.com/posts/2017-01-14-design-use-quickcheck.html">property based testing</a>. Instead of testing just
correct input and output like with <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> and <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a>, we focus on proving
properties or statements are correct for every possible value. <a href="https://en.wikipedia.org/wiki/Parity_(mathematics)">For
example with odd and even integers</a>, adding two even or odd integers
will always be even while adding an even and odd integer together
will always be odd. For testing abstract data types with little or no
state, testing structural properties is easier than asserting the
structure itself.
</p>

<p>
<b>Our first statement/property is that our AVL tree and BTree have
equal iterators</b> since it exercises the whole structure and order. To
assist in testing, we employ <a href="https://github.com/bluss/rust-itertools">rust-itertools</a> to test iterator equality
via <a href="https://docs.rs/itertools/0.6.0/itertools/fn.equal.html">itertools::equal</a> since it is better than using <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.zip">Iterator::zip</a> and
<a href="https://doc.rust-lang.org/std/macro.assert_eq.html">assert_eq!</a> in a for loop. We also implement the convenience trait,
<a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html">std::iter::IntoIterator</a>, to use <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collfect">IntoIterator::collect</a> method to
easily transforms iterators into other collections as shown below:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span><span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">FromIterator</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">from_iter</span><span style="color: #ff1493;">&lt;</span><span style="color: #ff694d;">I</span>: <span style="color: #f5b55f;">IntoIterator</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">Item</span> = <span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;(</span><span style="color: #ff694d;">iter</span>: <span style="color: #f5b55f;">I</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">Self</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = <span style="color: #f5b55f;">Self</span>::new<span style="color: #7fff00;">()</span>;

        <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">i</span> <span style="color: #96a5d9; font-weight: bold;">in</span> iter <span style="color: #7fff00;">{</span>
            set.insert<span style="color: #00bfff;">(</span>i<span style="color: #00bfff;">)</span>;
        <span style="color: #7fff00;">}</span>

        set
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>

<span style="color: #2872b2;">// </span><span style="color: #2872b2;">The power of IntoIterator</span>
<span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">vec</span> = <span style="color: #ff8c00;">(</span>1..10 <span style="color: #96a5d9; font-weight: bold;">as</span> <span style="color: #f5b55f;">u8</span><span style="color: #ff8c00;">)</span>.collect::<span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span>_<span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">&gt;()</span>;
<span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">avl</span>  = <span style="color: #ff8c00;">(</span>1..10 <span style="color: #96a5d9; font-weight: bold;">as</span> <span style="color: #f5b55f;">u8</span><span style="color: #ff8c00;">)</span>.collect::<span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff1493;">&lt;</span>_<span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">&gt;()</span>;
<span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">btree</span> = <span style="color: #ff8c00;">(</span>1..10 <span style="color: #96a5d9; font-weight: bold;">as</span> <span style="color: #f5b55f;">u8</span><span style="color: #ff8c00;">)</span>.collect::<span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">BTreeSet</span><span style="color: #ff1493;">&lt;</span>_<span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">&gt;()</span>;
</pre>
</div>

<p>
With all this foundation, creating a test for the iterator is precise:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">cfg</span><span style="color: #ff1493;">(</span><span style="color: #96a5d9;">test</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">mod</span> <span style="color: #afc0fd; font-weight: bold;">properties</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #96a5d9; font-weight: bold;">super</span>::*;
    <span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">std</span>::<span style="color: #afc0fd; font-weight: bold;">collections</span>::<span style="color: #f5b55f;">BTreeSet</span>;

    <span style="color: #96a5d9;">#</span><span style="color: #ff1493;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff1493;">]</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1. Create a random list</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">iterator_parity</span><span style="color: #ff1493;">(</span><span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">xs</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">usize</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff1493;">{</span>
        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">2. Create an empty AVL tree and BTree</span>
        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">3. For each element in the list, insert it to both tree</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">avl_set</span> = xs.iter<span style="color: #7fff00;">()</span>.cloned<span style="color: #7fff00;">()</span>.collect::<span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #00bfff;">&lt;</span>_<span style="color: #00bfff;">&gt;</span><span style="color: #7fff00;">&gt;()</span>;
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">btree_set</span> = xs.iter<span style="color: #7fff00;">()</span>.cloned<span style="color: #7fff00;">()</span>.collect::<span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">BTreeSet</span><span style="color: #00bfff;">&lt;</span>_<span style="color: #00bfff;">&gt;</span><span style="color: #7fff00;">&gt;()</span>;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">4. Both AVL and BTree iterator should be equal item per item</span>
        equal<span style="color: #7fff00;">(</span>avl_set.iter<span style="color: #00bfff;">()</span>, btree_set.iter<span style="color: #00bfff;">()</span><span style="color: #7fff00;">)</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Instead of <code>#[test]</code>, we use <code>#[quickcheck]</code> macro to indicate it is
a property based test. The actual mechanics of this style is that it
will generate a random value each argument in the function, run the
test and repeat it around <code>10,000</code> in an attempt to find a value that
returns <code>false</code> or breaks the test. In this case, the test creates
random <code>usize</code> lists and check the iterators as described above. The
generated lists are also not sorted and not unique that challenges
order and uniqueness. Until a <a href="https://en.wikipedia.org/wiki/Counterexample">counterexample</a> is found, we can assume
it correct.
</p>

<p>
We also check insert parity for completion:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
 <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">insert_parity</span><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">btree_set</span>: <span style="color: #f5b55f;">BTreeSet</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">u8</span><span style="color: #ff1493;">&gt;</span>, <span style="color: #ff694d;">x</span>: <span style="color: #f5b55f;">u8</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
     <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">avl_set</span> = btree_set.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

     avl_set.insert<span style="color: #ff1493;">(</span>x<span style="color: #ff1493;">)</span> == btree_set.insert<span style="color: #ff1493;">(</span>x<span style="color: #ff1493;">)</span>
 <span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
<b>Given an equal AVL and BTree set, <code>.insert</code> should be the same for
every value</b>. We can let <i>quickcheck</i> generate a random <code>BTreeSet</code> as
well and copy it in the same manner. Since <code>x</code> is also random, it is
either in the created sets or not that creates a positive and
negative case for inserting duplicates. With both tests written, we
run the tests with <code>cargo test</code>:
</p>

<div class="org-src-container">
<pre class="src src-text">  Compiling avl_tree_set_rs v0.1.0 (/home/nobody/avl_tree_set_rs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/avl_tree_set_rs-5f93a12c976aa84b

running 2 tests
test set::properties::iterator_parity ... ok
test set::properties::insert_parity ... ok
</pre>
</div>

<p>
We now have a working tree set. Of course, since we did not rebalance
the tree, we only crafted a standard binary tree but it is a start.
</p>
</div>
</div>

<div id="outline-container-orge54f2b1" class="outline-3">
<h3 id="orge54f2b1">Reflection</h3>
<div class="outline-text-3" id="text-orge54f2b1">
<p>
Working with <i>Rust</i> in this first section is not bad. Going back to a
static type system is reinvigorating. I really liked that structs,
pattern matching and <a href="https://en.wikipedia.org/wiki/Type_class">type classes</a> were included in the language, so I
had no problem there. Typing and understanding lifetime annotations
is one thing that made <i>Rust</i> different. Understanding the wide array
of traits and types itself is not trivial, so it is challenging how
their lifetime are factored in as well.
</p>

<p>
As a beginner, taking some time to look at the various traits and
types and their implementation made it click for me. Having the
documentation at the ready with <code>rustup doc --std</code> was great tooling.
Thankfully, we only require the basic concepts so it is more a
learning experience. So far, <i>Rust</i> does play like a low-level modern
language with some of the best modern features I value.
</p>
</div>
</div>
</div>

<div id="outline-container-org67ca508" class="outline-2">
<h2 id="org67ca508">Rebalancing</h2>
<div class="outline-text-2" id="text-org67ca508">
<p>
With a working binary tree, we apply the rebalancing strategy by
deciding how to implement height and node rotation. We then integrate
it back to <code>.insert</code> and update our test.
</p>

<ul class="org-ul">
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org27f7b7d">Balance Factor And Height</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org5312708">Unsafe Decision</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orga721430">Height Testing</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org551824d">Node Rotation</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orge1f3df9">Rotation Testing</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orge04009a">Rebalancing Insert</a></li>
</ul>
</div>

<div id="outline-container-org27f7b7d" class="outline-3">
<h3 id="org27f7b7d">Balance Factor And Height</h3>
<div class="outline-text-3" id="text-org27f7b7d">
<p>
Given a node, it has a <b>balance factor</b> that is the height of the
left tree minus the height of the right tree. The idea is that when
the balance factor grows to <code>2</code> or <code>-2</code>, a rotation of nodes or
transfer of nodes from one side to the other will fix the balance.
Starting with this definition, implementing the balance factor for
nodes is direct with some type truncation safety:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">left_height</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">usize</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.left.as_ref<span style="color: #7fff00;">()</span>.map_or<span style="color: #7fff00;">(</span>0, |left| left.height<span style="color: #00bfff;">()</span><span style="color: #7fff00;">)</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">right_height</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">usize</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.right.as_ref<span style="color: #7fff00;">()</span>.map_or<span style="color: #7fff00;">(</span>0, |right| right.height<span style="color: #00bfff;">()</span><span style="color: #7fff00;">)</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">pub</span> <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">balance_factor</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">i8</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">left_height</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.left_height<span style="color: #7fff00;">()</span>;
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">right_height</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.right_height<span style="color: #7fff00;">()</span>;

        <span style="color: #96a5d9; font-weight: bold;">if</span> left_height &gt;= right_height <span style="color: #7fff00;">{</span>
            <span style="color: #00bfff;">(</span>left_height - right_height<span style="color: #00bfff;">)</span> <span style="color: #96a5d9; font-weight: bold;">as</span> <span style="color: #f5b55f;">i8</span>
        <span style="color: #7fff00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #7fff00;">{</span>
            -<span style="color: #00bfff;">(</span><span style="color: #ffff00;">(</span>right_height - left_height<span style="color: #ffff00;">)</span> <span style="color: #96a5d9; font-weight: bold;">as</span> <span style="color: #f5b55f;">i8</span><span style="color: #00bfff;">)</span>
        <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Since our type uses <code>usize</code>, we need to consider subtraction
overflow. Assuming the tree is balanced, the balance factor can only
be from <code>-2</code> to <code>2</code>, so we can also use improve the return type from
<code>isize</code> to <code>i8</code> as a tiny optimization. However, if our tree does not
update height properly, we will have overflow from the smaller
datatype as a consequence. For the pragmatic, directly subtracting
the left and right height and using <code>isize</code> is valid but still holds
as a gentle reminder of what <a href="https://en.wikipedia.org/wiki/Integer_%28computer_science%29">unsigned integers</a> are and its design
impact.
</p>

<p>
Anyway, we need to define a <b>height</b> field that is defined
recursively as the larger height of the left or right subtree plus
one and empty trees have an empty height of zero. Word-for-word, it
is written as:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">std</span>::<span style="color: #afc0fd; font-weight: bold;">cmp</span>::max;

<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">height</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">usize</span> <span style="color: #ff8c00;">{</span>
    1 + max<span style="color: #ff1493;">(</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.left.as_ref<span style="color: #7fff00;">()</span>.map_or<span style="color: #7fff00;">(</span>0, |node| node.height<span style="color: #00bfff;">()</span><span style="color: #7fff00;">)</span>,
        <span style="color: #96a5d9; font-weight: bold;">self</span>.right.as_ref<span style="color: #7fff00;">()</span>.map_or<span style="color: #7fff00;">(</span>0, |node| node.height<span style="color: #00bfff;">()</span><span style="color: #7fff00;">)</span>,
    <span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Use <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or">Option::map_or</a> when you need map and unwrap with a default in one
go. However, updating ancestor nodes is expensive or inefficient when
it traverses the same node multiple times, so we turn this into a field to
cache the computation instead. Updating our definition of node:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">struct</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span><span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #ff694d;">value</span>: <span style="color: #f5b55f;">T</span>,
    <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,
    <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">New field</span>
    <span style="color: #ff694d;">height</span>: <span style="color: #f5b55f;">usize</span>,
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">update_height</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.height = 1 + max<span style="color: #7fff00;">(</span><span style="color: #96a5d9; font-weight: bold;">self</span>.left_height<span style="color: #00bfff;">()</span>, <span style="color: #96a5d9; font-weight: bold;">self</span>.right_height<span style="color: #00bfff;">()</span><span style="color: #7fff00;">)</span>;
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
After inserting or deleting a node, we need to traverse the ancestor
nodes to update their height as a trade-off. Definitions done,
implementing rotations was my first real struggle in <i>Rust</i>.
</p>
</div>
</div>

<div id="outline-container-org5312708" class="outline-3">
<h3 id="org5312708">Unsafe Decision</h3>
<div class="outline-text-3" id="text-org5312708">
<p>
How do we traverse upwards in our tree after every node insertion? A
quick solution is to add a mutable reference to the parent node and
use that to traverse until the root like so:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">derive</span><span style="color: #ff1493;">(</span><span style="color: #96a5d9;">Debug, PartialEq</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">struct</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #ff694d;">value</span>: <span style="color: #f5b55f;">T</span>,
    <span style="color: #ff694d;">left</span>: <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Sad, extra annotations required</span>
    <span style="color: #ff694d;">right</span>: <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff1493;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>,
    <span style="color: #ff694d;">height</span>: <span style="color: #f5b55f;">usize</span>,

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">New field</span>
    <span style="color: #ff694d;">parent_node</span>: <span style="color: #f5b55f;">Option</span><span style="color: #ff1493;">&lt;</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span>,
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">update_ancestors_height</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.update_height<span style="color: #7fff00;">()</span>;

        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">current_node</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>;
        <span style="color: #96a5d9; font-weight: bold;">while</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span>parent_node<span style="color: #7fff00;">)</span> = current_node.parent_node <span style="color: #7fff00;">{</span>
            parent_node.update_height<span style="color: #00bfff;">()</span>;
            current_node = parent_node;
        <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
However, this creates a <a href="https://doc.rust-lang.org/book/ch15-06-reference-cycles.html?highlight=Weak#preventing-reference-cycles-turning-an--rct--into-a--weakt">cyclic reference</a> between parent and child
which is dangerous and discouraged in <i>Rust</i>. Personally, it also
makes the design dirtier that requiring a reference only for
traversing upwards on insert and delete operations seems overkill.
Going back to <code>.insert</code>, we can track them with a stack instead via
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push">Vec::push</a> mechanics:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">insert</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>, <span style="color: #ff694d;">value</span>: <span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">prev_nodes</span> = <span style="color: #f5b55f;">Vec</span>::<span style="color: #ff1493;">&lt;</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span>::new<span style="color: #ff1493;">()</span>;

    <span style="color: #96a5d9; font-weight: bold;">while</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>current_node<span style="color: #ff1493;">)</span> = current_tree <span style="color: #ff1493;">{</span>
        prev_nodes.push<span style="color: #7fff00;">(</span>current_node<span style="color: #7fff00;">)</span>;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">match ...</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Traversing a list as a stack needs to be reversed via .rev first</span>
    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">node</span> <span style="color: #96a5d9; font-weight: bold;">in</span> prev_nodes.into_iter<span style="color: #ff1493;">()</span>.rev<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        node.update_height<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">true</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
The problem here is that <code>current_node</code> is mutable borrowed twice:
one for a mutable left or right child node and one for traversed
stack/vector. I would argue that the mutability of the tracking nodes
is safe since it is used after the insert mutation is done. Crawling
the web for idiomatic solutions, the suggested strategy is to use the
combination of a <a href="https://doc.rust-lang.org/std/rc/index.html">reference counted pointer</a> and <a href="https://doc.rust-lang.org/std/cell/index.html">interior mutable cell</a>
or <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> pattern to allow multiple mutable references. I
initially thought I could use this just in the function itself
without changing the definition of the node but I could not:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">std</span>::<span style="color: #afc0fd; font-weight: bold;">rc</span>::<span style="color: #f5b55f;">Rc</span>;
<span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">std</span>::<span style="color: #afc0fd; font-weight: bold;">cell</span>::<span style="color: #f5b55f;">RefCell</span>;

<span style="color: #96a5d9; font-weight: bold;">type</span> <span style="color: #f5b55f;">AvlTree</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> = <span style="color: #f5b55f;">Option</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">Rc</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">RefCell</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">AvlNode</span><span style="color: #00bfff;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #00bfff;">&gt;</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">&gt;</span>;
</pre>
</div>

<p>
To use them as intended, we would need to own the data we are using;
however that is not possible since we are behind a mutable reference,
<code>&amp;mut self</code>. Even if I could make the code work, the fact that I had
to change the types and include reference counting complicates the
design needlessly just to retrace the nodes. Up to this point, I find
<i>Rust</i>'s strictness comforting in spite of my struggle; however, I
feel that I need to loosen up the restriction a bit to avoid
unnecessary complexity. In this case, we want to allow one secondary
mutable reference after insertion and doing this requires <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Unsafe
Rust</a>. <b>Unsafe Rust</b> allows us to ignore borrowing rules for
mutability as specified in this <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">section of the book</a>. Using raw
pointers allows our implementation to be uncomplicated:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">insert</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>, <span style="color: #ff694d;">value</span>: <span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">prev_ptrs</span> = <span style="color: #f5b55f;">Vec</span>::<span style="color: #ff1493;">&lt;</span>*<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span>::new<span style="color: #ff1493;">()</span>;

    <span style="color: #96a5d9; font-weight: bold;">while</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>current_node<span style="color: #ff1493;">)</span> = current_tree <span style="color: #ff1493;">{</span>
        prev_ptrs.push<span style="color: #7fff00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> **current_node<span style="color: #7fff00;">)</span>;   <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Converting a mutable reference to a pointer</span>

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">... match ...</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">... insert ...</span>

    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">node_ptr</span> <span style="color: #96a5d9; font-weight: bold;">in</span> prev_ptrs.into_iter<span style="color: #ff1493;">()</span>.rev<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">node</span> = <span style="color: #f5b55f; text-decoration: underline;">unsafe</span> <span style="color: #7fff00;">{</span> &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> *node_ptr <span style="color: #7fff00;">}</span>;  <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Converting a mutable pointer back to a reference</span>
        node.update_height<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">true</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
The arcane magic of unsafe is better explained in the <a href="https://doc.rust-lang.org/nomicon/borrow-splitting.html?highlight=Tree#splitting-borrows">Rustonomicon</a>
which I plan to read after writing this. Since we told <i>Rust</i> to
trust us, we need to guarantee our function is safe. The most visible
angle is the one using <code>unsafe</code> or the raw pointers themselves. The
mutable method, <code>.update_height</code>, only requires that its children
have the correct height before updating itself. As an anecdote, I
forgot to reverse the list before iterating (since push operation
append at the end) and caused incorrect node heights because the
parents were updated before the children. With this possibility, we
also need to test the height property.
</p>
</div>
</div>

<div id="outline-container-orga721430" class="outline-3">
<h3 id="orga721430">Height Testing</h3>
<div class="outline-text-3" id="text-orga721430">
<p>
<b>Given any AVL tree set, each node's height is one more than the
larger height of the left or right subtree</b>. To make testing easier,
we can do two short things. First, instead of pattern matching the
structure, we can refactor <code>.iter</code> to emit the nodes instead of their
values <code>.node_iter</code>:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Using impl Traits</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">iter</span><span style="color: #ff1493;">(</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #96a5d9; font-weight: bold;">impl</span> <span style="color: #f5b55f;">Iterator</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Item</span> = &amp;'<span style="color: #ff694d;">a</span> <span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span> + '<span style="color: #ff694d;">a</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.node_iter<span style="color: #7fff00;">()</span>.map<span style="color: #7fff00;">(</span>|node| &amp;node.value<span style="color: #7fff00;">)</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">node_iter</span><span style="color: #ff1493;">(</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #96a5d9; font-weight: bold;">impl</span> <span style="color: #f5b55f;">Iterator</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Item</span> = &amp;'<span style="color: #ff694d;">a</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span> + '<span style="color: #ff694d;">a</span> <span style="color: #ff1493;">{</span>
        <span style="color: #f5b55f;">AvlTreeSetNodeIter</span> <span style="color: #7fff00;">{</span>
            <span style="color: #ff694d;">prev_nodes</span>: <span style="color: #f5b55f;">Vec</span>::default<span style="color: #00bfff;">()</span>,
            <span style="color: #ff694d;">current_tree</span>: &amp;<span style="color: #96a5d9; font-weight: bold;">self</span>.root,
        <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
As an aside, I suggest learning <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits">impl Traits</a> that allows you to
return an abstract trait type instead of the concrete type as in
<a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphism</a>. Using that, we can implement <a href="https://doc.rust-lang.org/std/iter/index.html#adapters">generic iterator adapters</a>
for <code>.iter</code> that maps over <code>.node_iter</code>. Without it, creating
abstractions on top of another becomes a noisy type fest:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">core</span>::<span style="color: #afc0fd; font-weight: bold;">iter</span>::<span style="color: #f5b55f;">Map</span>;

<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">iter</span><span style="color: #ff8c00;">(</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">Map</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">AvlTreeSetNodeIter</span><span style="color: #ff1493;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #ff1493;">&gt;</span>, <span style="color: #96a5d9; font-weight: bold;">fn</span><span style="color: #ff1493;">(</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">)</span> -&gt; &amp;<span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">self</span>.node_iter<span style="color: #ff1493;">()</span>.map<span style="color: #ff1493;">(</span>|node| &amp;node.value<span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">node_iter</span><span style="color: #ff8c00;">(</span>&amp;'<span style="color: #ff694d;">a</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">AvlTreeSetNodeIter</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #f5b55f;">AvlTreeSetNodeIter</span> <span style="color: #ff1493;">{</span>
        <span style="color: #ff694d;">prev_nodes</span>: <span style="color: #f5b55f;">Vec</span>::default<span style="color: #7fff00;">()</span>,
        <span style="color: #ff694d;">current_tree</span>: &amp;<span style="color: #96a5d9; font-weight: bold;">self</span>.root,
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Going back, the new <code>AvlTreeSetNodeIter</code> is a copied version of the
original iterator with <code>Some(&amp;current_node.value)</code> replaced to
<code>Some(&amp;current_node)</code>. Moving on the second item, instead of creating
the sets through <code>.collect</code> method; we can also have it generated by
implementing the <code>Arbitrary</code> trait ourselves:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">quickcheck</span>::<span style="color: #ff8c00;">{</span><span style="color: #f5b55f;">Arbitrary</span>, <span style="color: #f5b55f;">Gen</span><span style="color: #ff8c00;">}</span>;

<span style="color: #2872b2;">// </span><span style="color: #2872b2;">Refit and copied from quickcheck</span>
<span style="color: #2872b2;">// </span><span style="color: #2872b2;">https://docs.rs/quickcheck/0.8.5/src/quickcheck/arbitrary.rs.html</span><span style="color: #ffffff; background-color: #385;">#385</span><span style="color: #2872b2;">-395</span>
<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span><span style="color: #ff694d;">T</span>: <span style="color: #f5b55f;">Arbitrary</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">Arbitrary</span> <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">arbitrary</span><span style="color: #ff1493;">&lt;</span><span style="color: #ff694d;">G</span>: <span style="color: #f5b55f;">Gen</span><span style="color: #ff1493;">&gt;(</span><span style="color: #ff694d;">g</span>: &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">G</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">Self</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">vec</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span> = <span style="color: #f5b55f;">Arbitrary</span>::arbitrary<span style="color: #7fff00;">(</span>g<span style="color: #7fff00;">)</span>;
        vec.into_iter<span style="color: #7fff00;">()</span>.collect<span style="color: #7fff00;">()</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">shrink</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">Box</span><span style="color: #ff1493;">&lt;</span><span style="color: #96a5d9; font-weight: bold;">dyn</span> <span style="color: #f5b55f;">Iterator</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">Item</span> = <span style="color: #f5b55f;">Self</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">vec</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.iter<span style="color: #7fff00;">()</span>.cloned<span style="color: #7fff00;">()</span>.collect<span style="color: #7fff00;">()</span>;
        <span style="color: #f5b55f;">Box</span>::new<span style="color: #7fff00;">(</span>vec.shrink<span style="color: #00bfff;">()</span>.map<span style="color: #00bfff;">(</span>|v| v.into_iter<span style="color: #ffff00;">()</span>.collect::<span style="color: #ffff00;">&lt;</span><span style="color: #f5b55f;">Self</span><span style="color: #ffff00;">&gt;()</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Putting those two together, we have another simple test:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">std</span>::<span style="color: #afc0fd; font-weight: bold;">cmp</span>::max;
<span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">itertools</span>::all;

<span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">node_height</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">set</span>: <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">u16</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    all<span style="color: #ff1493;">(</span>set.node_iter<span style="color: #7fff00;">()</span>, |node| <span style="color: #7fff00;">{</span>
        node.height == 1 + max<span style="color: #00bfff;">(</span>node.left_height<span style="color: #ffff00;">()</span>, node.right_height<span style="color: #ffff00;">()</span><span style="color: #00bfff;">)</span>
    <span style="color: #7fff00;">}</span><span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Another succinct test that <code>.update_height</code> correctly updates the
child all the way up to the root and that our use of <code>unsafe</code> is
truly safe. Whether you agree with my use of <code>unsafe</code>, I learned a
certain reverence in asking permission to use dangerous features and
heightened responsibility in upholding the law that reminds me of
<a href="https://wiki.haskell.org/IO_inside">Haskell's IO</a> boundaries. Nonetheless, we can now tackle node
rotation.
</p>
</div>
</div>

<div id="outline-container-org551824d" class="outline-3">
<h3 id="org551824d">Node Rotation</h3>
<div class="outline-text-3" id="text-org551824d">
<p>
After inserting a node in a balanced AVL tree, it becomes
<b>imbalanced</b> when a node has a left and right subtree height
difference of <code>2</code> or <code>-2</code>. To correct this, we move nodes around while
preserving order. Visualizing the operation for rotating nodes to the
right:
</p>

<p>
<img src="./Understanding_Rust_Through_AVL_Trees_files/avl-trees--right-rotation.jpg" alt="Visualization of Right Rotation">
</p>

<p>
Given a node, the idea is to promote the left child as the root and
demote the old root as a right child. While retaining other node
relationships, the orphaned left-right child of the old root is now
the right-left child of the new root. Those two movements constitute
the right rotation of nodes. As a general observation, moving nodes
from one side to the other should change the balance factor. Based on
the diagram above, we can say it changes by <code>2</code> perhaps. We'll verify
this observation later.
</p>

<p>
Implementing the rotation took me a long time to do with two primary
constraints. First was to avoid using <code>unsafe</code> again. Another is to
avoid create another node or heap allocated pointer via <code>Box::new</code> to
be memory efficient. After several attempts, I came up with this safe
implementation of right rotation:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">std</span>::<span style="color: #afc0fd; font-weight: bold;">mem</span>::<span style="color: #ff8c00;">{</span>replace, swap<span style="color: #ff8c00;">}</span>;

<span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">rotate_right</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.left.is_none<span style="color: #7fff00;">()</span> <span style="color: #7fff00;">{</span>
            <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #96a5d9; font-weight: bold;">false</span>;
        <span style="color: #7fff00;">}</span>

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1. Take nodes A and C</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">left_node</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.left.as_mut<span style="color: #7fff00;">()</span>.unwrap<span style="color: #7fff00;">()</span>;
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">left_right_tree</span> = left_node.right.take<span style="color: #7fff00;">()</span>;
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">left_left_tree</span> = left_node.left.take<span style="color: #7fff00;">()</span>;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">2. Link A node to left node</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">new_right_tree</span> = replace<span style="color: #7fff00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.left, left_left_tree<span style="color: #7fff00;">)</span>;
        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">3. Swap B and D node value to avoid moving the root</span>
        swap<span style="color: #7fff00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.value, &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> new_right_tree.as_mut<span style="color: #00bfff;">()</span>.unwrap<span style="color: #00bfff;">()</span>.value<span style="color: #7fff00;">)</span>;
        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">4. Take E node</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">right_tree</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.right.take<span style="color: #7fff00;">()</span>;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">5. Link C and E nodes to swapped D node</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">new_right_node</span> = new_right_tree.as_mut<span style="color: #7fff00;">()</span>.unwrap<span style="color: #7fff00;">()</span>;
        new_right_node.left = left_right_tree;
        new_right_node.right = right_tree;
        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">6. Link swapped D node to root right node</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.right = new_right_tree;

        <span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span>node<span style="color: #7fff00;">)</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.right.as_mut<span style="color: #7fff00;">()</span> <span style="color: #7fff00;">{</span>
            node.update_height<span style="color: #00bfff;">()</span>;
        <span style="color: #7fff00;">}</span>

        <span style="color: #96a5d9; font-weight: bold;">self</span>.update_height<span style="color: #7fff00;">()</span>;

        <span style="color: #96a5d9; font-weight: bold;">true</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
By carefully using <a href="https://doc.rust-lang.org/std/mem/fn.swap.html?search=">std::mem::swap</a> and <a href="https://doc.rust-lang.org/std/mem/fn.replace.html">std::mem::replace</a>, we avoid
creating nodes by replacing the value and links of an existing node
instead. The main idea is about taking nodes from the left side and
placing them on the right carefully. Referring to the rotation
diagram while stepping through the code might help. After rotating,
we also need to update the heights of the right tree and the node
itself since they had new nodes. One minor thing is that we also
return a flag to indicate that the operation was executed or not for
our tests later. To compare and contrast, my first version is indeed
shorter yet memory inefficient:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">pub</span> <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">rotate_right</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>

    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">left_right_tree</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.left.as_mut<span style="color: #ff1493;">()</span>.unwrap<span style="color: #ff1493;">()</span>.right.take<span style="color: #ff1493;">()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">new_root</span> = *replace<span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.left, left_right_tree<span style="color: #ff1493;">)</span>.unwrap<span style="color: #ff1493;">()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">old_root</span> = replace<span style="color: #ff1493;">(</span><span style="color: #96a5d9; font-weight: bold;">self</span>, new_root<span style="color: #ff1493;">)</span>;

    replace<span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.right, <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span><span style="color: #f5b55f;">Box</span>::new<span style="color: #00bfff;">(</span>old_root<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>; <span style="color: #2872b2;">// </span><span style="color: #2872b2;">New pointer created here</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Assuming it is correct in either version, implementing the left
rotation is a bit of cheat by swapping every <code>left</code> with <code>right</code> text
in the function since they are symmetrical. To say that we have
working and safe rotations after days of working back and forth is
nothing short of bliss. As we did before, we need to prove it works.
</p>
</div>
</div>

<div id="outline-container-orge1f3df9" class="outline-3">
<h3 id="orge1f3df9">Rotation Testing</h3>
<div class="outline-text-3" id="text-orge1f3df9">
<p>
We have two statements to test about node rotation: <b>rotations should
preserve order and adjust the balance factor</b>. With everything
previously setup, we can test the first statement directly:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">quickcheck</span>::<span style="color: #f5b55f;">TestResult</span>;

<span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">rotate_right_preserves_order</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">btree</span>: <span style="color: #f5b55f;">BTreeSet</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">u8</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">TestResult</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = btree.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    <span style="color: #96a5d9; font-weight: bold;">if</span> !set.root.is_some<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">TestResult</span>::discard<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">if</span> !set.root.as_mut<span style="color: #ff1493;">()</span>.unwrap<span style="color: #ff1493;">()</span>.rotate_right<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">TestResult</span>::discard<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #f5b55f;">TestResult</span>::from_bool<span style="color: #ff1493;">(</span>equal<span style="color: #7fff00;">(</span>set.iter<span style="color: #00bfff;">()</span>, btree.iter<span style="color: #00bfff;">()</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Given a BTree, we clone that to an AVL and right rotate the root node
and check if the resulting iterators still matches in order and
value. We also want to ignore empty trees and nodes that cannot not
be rotated since they do not add value. For that, we use the <a href="https://github.com/BurntSushi/quickcheck#discarding-test-results-or-properties-are-polymorphic">discard
test</a> mechanics of <i>quickcheck</i> with a <a href="https://docs.rs/quickcheck/0.8.5/quickcheck/struct.TestResult.html#method.discard">quickcheck::TestResult</a> output
instead. If a test is <a href="https://docs.rs/quickcheck/0.8.5/quickcheck/struct.TestResult.html#method.discard">discarded</a>, a new test sample is created instead
of ignoring it that would have eaten the maximum number of tests.
Same tactic applies to writing the left rotation.
</p>

<p>
First statement down, we now check if right rotation does tilt the
balance factor say by <code>2</code>:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">rotate_right_tils_balance_factor</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">xs</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">u32</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">TestResult</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = xs.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    <span style="color: #96a5d9; font-weight: bold;">if</span> !set.root.is_some<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">TestResult</span>::discard<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">root_node</span> = set.root.as_mut<span style="color: #ff1493;">()</span>.unwrap<span style="color: #ff1493;">()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">balance_factor</span> = root_node.balance_factor<span style="color: #ff1493;">()</span>;

    <span style="color: #96a5d9; font-weight: bold;">if</span> !root_node.rotate_right<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">TestResult</span>::discard<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">tilted_factor</span> = root_node.balance_factor<span style="color: #ff1493;">()</span>;

    <span style="color: #f5b55f;">TestResult</span>::from_bool<span style="color: #ff1493;">(</span>balance_factor - tilted_factor == 2<span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Running just this test with <code>cargo test
   rotate_right_tilts_balance_factor</code>, this test fails on the list <code>[2,
   0, 1]</code>:
</p>

<div class="org-src-container">
<pre class="src src-text">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running target/debug/deps/avl_tree_set-ac5259255f5174fd

running 1 test
thread 'set::properties::rotate_right_tilts_balance_factor' panicked at '[quickcheck] TEST FAILED. Arguments: ([2, 0, 1])',
/* More errors */
</pre>
</div>


<p>
Visualizing this counterexample:
</p>

<p>
<img src="./Understanding_Rust_Through_AVL_Trees_files/avl-trees--right-rotation-balance-factor-counterexample.jpg" alt="Visualization of Right Rotation Counterexample">
</p>

<p>
Given this diagram, the balance factor is changed from <code>2</code> to <code>-2</code>
that has a difference of <code>4</code> that fails the test. Even accommodating
that, the next counterexample is <code>[2, 0, 1, 3]</code> where the balance
factor is <code>1</code> turned to <code>-2</code> with a difference of <code>3</code>. With
subsequent exploration, the difference is always at least <code>2</code> but the
upper bound is unknown. This is where property based testing is
meaningful in expanding our empirical observation. Nonetheless, the
tilt still exists that proves that the rotation works although
weakly. We then update the condition to test a difference of at least
<code>2</code> to pass and apply a similar treatment to writing the left
rotation test.
</p>

<p>
To connect these two rotations in one property, what can we say about
those two operations when applied together? Can we say they are
<a href="https://en.wikipedia.org/wiki/Inverse_function">inverse operations</a> that a right rotation undoes a left rotation or
vice-versa like with multiplication and division? Again, easily
verified:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">rotate_left_and_rotate_left_identity</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">set</span>: <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">u8</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">TestResult</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">if</span> set.root.is_none<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">TestResult</span>::discard<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">rotated_set</span> = set.clone<span style="color: #ff1493;">()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">root_node</span> = rotated_set.root.as_mut<span style="color: #ff1493;">()</span>.unwrap<span style="color: #ff1493;">()</span>;

    <span style="color: #96a5d9; font-weight: bold;">if</span> root_node.rotate_left<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        root_node.rotate_right<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #ff1493;">{</span>
        root_node.rotate_right<span style="color: #7fff00;">()</span>;
        root_node.rotate_left<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #f5b55f;">TestResult</span>::from_bool<span style="color: #ff1493;">(</span>rotated_set == set<span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Given a set, we clone that and rotate left then right or whichever
applies first, then check if it is the same structure. Running the
test proves it is valid since no breaking example can be found:
</p>

<div class="org-src-container">
<pre class="src src-text">   Compiling avl_tree_set v0.1.0 (/home/nobody/avl_tree_set_rs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/avl_tree_set-ac5259255f5174fd

running 5 tests
test set::properties::rotate_left_and_rotate_left_identity ... ok
test set::properties::rotate_left_tilts_balance_factor ... ok
test set::properties::rotate_right_tilts_balance_factor ... ok
test set::properties::rotate_left_preserves_order ... ok
test set::properties::rotate_right_preserves_order ... ok
/* Omitted other results */
</pre>
</div>

<p>
With confidence from those supporting statements, we are now ready to
finish our insert method.
</p>
</div>
</div>

<div id="outline-container-orge04009a" class="outline-3">
<h3 id="orge04009a">Rebalancing Insert</h3>
<div class="outline-text-3" id="text-orge04009a">
<p>
If we have an imbalanced node, then wouldn't one correct rotation
restore balance? It is a good first intuition but our small
counterexample on the tilt property disproves that. However, we can
apply another rotation to a child node before applying the main
rotation and it is enough to work. You can find a <a href="https://www.cs.wcupa.edu/rkline/ds/avl-trees.html">mathematical proof
of induction here</a> if you are interested. Theory aside, the algorithm
can be thought of as branching paths:
</p>

<ol class="org-ol">
<li>Give a root node, if the balance factor is <code>2</code> (left heavy), we inspect
the left node.</li>
<li>If the left node has a balance factor of <code>1</code> (left heavy), we just
right rotate on the root node.</li>
<li>Otherwise, we left rotate this inner left node and right rotate
the root node.</li>
<li>Going back to the root node, if the balance factor is instead <code>-2</code>
(right heavy), we inspect the right node.</li>
<li>If the right node has a balance factor of <code>-1</code> (right heavy), we just
left rotate the root node.</li>
<li>Otherwise, we right rotate the inner right node and left rotate
the root node.</li>
</ol>

<p>
Translating this into code is rather direct with pattern matching:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">rebalance</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">match</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.balance_factor<span style="color: #7fff00;">()</span> <span style="color: #7fff00;">{</span>
            -2 =&gt; <span style="color: #00bfff;">{</span>
                <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Root is right heavy</span>
                <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">right_node</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.right.as_mut<span style="color: #ffff00;">()</span>.unwrap<span style="color: #ffff00;">()</span>;

                <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Inner node is left heavy</span>
                <span style="color: #96a5d9; font-weight: bold;">if</span> right_node.balance_factor<span style="color: #ffff00;">()</span> == 1 <span style="color: #ffff00;">{</span>
                    right_node.rotate_right<span style="color: #da70d6;">()</span>;
                <span style="color: #ffff00;">}</span>

                <span style="color: #96a5d9; font-weight: bold;">self</span>.rotate_left<span style="color: #ffff00;">()</span>;

                <span style="color: #96a5d9; font-weight: bold;">true</span>
            <span style="color: #00bfff;">}</span>

            2 =&gt; <span style="color: #00bfff;">{</span>
                <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Root is left heavy</span>
                <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">left_node</span> = <span style="color: #96a5d9; font-weight: bold;">self</span>.left.as_mut<span style="color: #ffff00;">()</span>.unwrap<span style="color: #ffff00;">()</span>;

                <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Inner node is right heavy</span>
                <span style="color: #96a5d9; font-weight: bold;">if</span> left_node.balance_factor<span style="color: #ffff00;">()</span> == -1 <span style="color: #ffff00;">{</span>
                    left_node.rotate_left<span style="color: #da70d6;">()</span>;
                <span style="color: #ffff00;">}</span>

                <span style="color: #96a5d9; font-weight: bold;">self</span>.rotate_right<span style="color: #ffff00;">()</span>;

                <span style="color: #96a5d9; font-weight: bold;">true</span>
            <span style="color: #00bfff;">}</span>
            _ =&gt; <span style="color: #96a5d9; font-weight: bold;">false</span>,
        <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
We directly integrate this method back to <code>.insert</code> as planned:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">insert</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>, <span style="color: #ff694d;">value</span>: <span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>

    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">node_ptr</span> <span style="color: #96a5d9; font-weight: bold;">in</span> prev_ptrs.into_iter<span style="color: #ff1493;">()</span>.rev<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">node</span> = <span style="color: #f5b55f; text-decoration: underline;">unsafe</span> <span style="color: #7fff00;">{</span> &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> *node_ptr <span style="color: #7fff00;">}</span>;

        node.update_height<span style="color: #7fff00;">()</span>;
        node.rebalance<span style="color: #7fff00;">()</span>;    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Right here</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">true</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
To test the rebalancing property, we assert that every node should
not be imbalanced which is similar to the height test:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">balanced_nodes</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">set</span>: <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">u16</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    all<span style="color: #ff1493;">(</span>set.node_iter<span style="color: #7fff00;">()</span>, |node| node.balance_factor<span style="color: #7fff00;">()</span>.abs<span style="color: #7fff00;">()</span> &lt; 2<span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Running this and all prior test specially with the height and
iterator property proves that our tree is balanced after every
insert:
</p>

<div class="org-src-container">
<pre class="src src-shell">   Compiling avl_tree_set v0.1.0 <span style="color: #ff8c00;">(</span>/home/nobody/avl_tree_set_rs<span style="color: #ff8c00;">)</span>
    Finished dev <span style="color: #ff8c00;">[</span>unoptimized + debuginfo<span style="color: #ff8c00;">]</span> target<span style="color: #ff8c00;">(</span>s<span style="color: #ff8c00;">)</span> <span style="color: #96a5d9; font-weight: bold;">in</span> 0.27s
     Running target/debug/deps/avl_tree_set-ac5259255f5174fd

running 3 tests
<span style="color: #96a5d9; font-style: italic;">test</span> set::properties::balanced_nodes ... ok
<span style="color: #96a5d9; font-style: italic;">test</span> set::properties::node_height ... ok
<span style="color: #96a5d9; font-style: italic;">test</span> set::properties::iterator_parity ... ok
/* Omitting other tests */
</pre>
</div>

<p>
We now have a self-balancing tree and can now proclaim victory.
</p>
</div>
</div>

<div id="outline-container-orga2066bb" class="outline-3">
<h3 id="orga2066bb">Reflection</h3>
<div class="outline-text-3" id="text-orga2066bb">
<p>
This was a challenging section. In particular with rotation, it was
hard to negotiate with the compiler how to move the nodes correctly.
In my darkest hour, I was truly tempted to use <code>unsafe</code> to move the
pointers directly (if I could) as <i>C</i> code seems so deceptively easy;
however, I would increase the error margin/surface of the design.
This problem was less about writing and technicalities but more about
understanding that requires patience and rigor. After this, I stopped
resisting the compiler and started to accept it.
</p>
</div>
</div>
</div>

<div id="outline-container-org751b358" class="outline-2">
<h2 id="org751b358">Deletion</h2>
<div class="outline-text-2" id="text-org751b358">
<p>
After all the struggle with <code>.insert</code>, the deletion method, <code>.take</code>,
is surprisingly the harder of the two methods. When deleting nodes, we
have to handle three cases for the deleted node to maintain the tree
structure: no children, one child and two children. This section is a
culmination of all the techniques.
</p>

<ul class="org-ul">
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org5902901">Delete Method</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org548e1a5">Zero Or One Child</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org73303ed">Two Children</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#orgd1d4e25">Deletion Testing</a></li>
</ul>
</div>

<div id="outline-container-org5902901" class="outline-3">
<h3 id="org5902901">Delete Method</h3>
<div class="outline-text-3" id="text-org5902901">
<p>
<b>Parity:</b> <a href="https://doc.rust-lang.org/std/collections/btree_set/struct.BTreeSet.html#method.take">BTreeSet::take</a>
</p>

<p>
If you noticed <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.take">Option::take</a> when rotating nodes, it returns the owned
value and internally replaced by a <code>None</code> value. For our tree, our
<code>.take</code> method follows the same convention. Here is the whole
procedure to delete a node:
</p>

<ol class="org-ol">
<li>Starting from the root node or with a current node</li>
<li>Move to the left node if the value is less than the current node,
right if greater</li>
<li>Do this until you have a node equal to that value, otherwise stop</li>
<li>Delete that node and return the value</li>
<li>If the deleted node has no children, stop</li>
<li>If the deleted node has one child, substitute that child to
the removed node</li>
<li>If the deleted node has two children, substitute the deleted node
with the leftmost child of the right subtree and link the orphaned
left child to the left child of this new node</li>
</ol>

<p>
These steps are short to write but are deceptively tricky but the
first few are done in the same manner as we did with <code>.insert</code>:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">take</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>, <span style="color: #ff694d;">value</span>: &amp;<span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">Option</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">prev_ptrs</span> = <span style="color: #f5b55f;">Vec</span>::<span style="color: #ff1493;">&lt;</span>*<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span>::new<span style="color: #ff1493;">()</span>;
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1. Starting from the root node or with a current node</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">current_tree</span> = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>.root;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">target_value</span> = <span style="color: #f5b55f;">None</span>;

    <span style="color: #96a5d9; font-weight: bold;">while</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>current_node<span style="color: #ff1493;">)</span> = current_tree <span style="color: #ff1493;">{</span>
        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">2. Move to the left node if the value is less than the current node,</span>
        <span style="color: #2872b2;">//    </span><span style="color: #2872b2;">right if greater</span>
        <span style="color: #96a5d9; font-weight: bold;">match</span> current_node.value.cmp<span style="color: #7fff00;">(</span>&amp;value<span style="color: #7fff00;">)</span> <span style="color: #7fff00;">{</span>
            <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Less</span> =&gt; <span style="color: #00bfff;">{</span>
                prev_ptrs.push<span style="color: #ffff00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> **current_node<span style="color: #ffff00;">)</span>;
                current_tree = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> current_node.right;
            <span style="color: #00bfff;">}</span>
            <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Equal</span> =&gt; <span style="color: #00bfff;">{</span>
                <span style="color: #2872b2;">// </span><span style="color: #2872b2;">3a. Do this until you have a node equal to that value, ...</span>
                target_value = <span style="color: #f5b55f;">Some</span><span style="color: #ffff00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> **current_node<span style="color: #ffff00;">)</span>;
                <span style="color: #96a5d9; font-weight: bold;">break</span>;
            <span style="color: #00bfff;">}</span>
            <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Greater</span> =&gt; <span style="color: #00bfff;">{</span>
                prev_ptrs.push<span style="color: #ffff00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> **current_node<span style="color: #ffff00;">)</span>;
                current_tree = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> current_node.left;
            <span style="color: #00bfff;">}</span>
        <span style="color: #7fff00;">}</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">3b. ... otherwise stop</span>
    <span style="color: #96a5d9; font-weight: bold;">if</span> target_value.as_ref<span style="color: #ff1493;">()</span>.is_none<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #f5b55f;">None</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">target_node</span> = target_value.unwrap<span style="color: #ff1493;">()</span>;

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">4. Delete that node and return the value</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">taken_value</span> = <span style="color: #96a5d9; font-weight: bold; font-style: italic;">???</span>;

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Retrace the path and update them accordingly</span>
    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">node_ptr</span> <span style="color: #96a5d9; font-weight: bold;">in</span> prev_ptrs.into_iter<span style="color: #ff1493;">()</span>.rev<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">node</span> = <span style="color: #f5b55f; text-decoration: underline;">unsafe</span> <span style="color: #7fff00;">{</span> &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> *node_ptr <span style="color: #7fff00;">}</span>;
        node.update_height<span style="color: #7fff00;">()</span>;
        node.rebalance<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>taken_value<span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
This is the <code>.insert</code> method with some modifications. We need the
node before <code>.insert</code> stops, so the <code>target_value</code> captures that
idea. It is also wrapped in an <code>Option</code> to see check if a node is
found and stop otherwise. Also, we use <code>taken_value</code> as the return
value after deleting the node. Before exiting, we make sure the
tracked nodes are updated before we leave.
</p>

<p>
To emphasize, deleting or relocating nodes is a tricky operation
since it potentially moves many nodes. We exercise care as we handle
each case and consider height and balance if needed. Failing to
update nodes correctly will lead to subtle memory issues such as
mentioned in <code>.balance_factor</code> and dropped nodes. We naturally start
with the safer case of zero or one child for the deleted node.
</p>
</div>
</div>

<div id="outline-container-org548e1a5" class="outline-3">
<h3 id="org548e1a5">Zero Or One Child</h3>
<div class="outline-text-3" id="text-org548e1a5">
<p>
The case of deleting an empty node is about detaching the target
node. With one child either left or right, we still delete the node
and promote that child in its place. Weirdly, the case of deleting
one child is easier than deleting no child:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">take</span><span style="color: #ff8c00;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #96a5d9; font-weight: bold;">self</span>, <span style="color: #ff694d;">value</span>: &amp;<span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">Option</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Deleting the node here</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">taken_value</span> = <span style="color: #96a5d9; font-weight: bold;">if</span> target_node.left.is_none<span style="color: #ff1493;">()</span> || target_node.right.is_none<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span>left_node<span style="color: #7fff00;">)</span> = target_node.left.take<span style="color: #7fff00;">()</span> <span style="color: #7fff00;">{</span>
            replace<span style="color: #00bfff;">(</span>target_node, *left_node<span style="color: #00bfff;">)</span>.value
        <span style="color: #7fff00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span>right_node<span style="color: #7fff00;">)</span> = target_node.right.take<span style="color: #7fff00;">()</span> <span style="color: #7fff00;">{</span>
            replace<span style="color: #00bfff;">(</span>target_node, *right_node<span style="color: #00bfff;">)</span>.value
        <span style="color: #7fff00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #7fff00;">{</span>
            <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Deleting an no children</span>
        <span style="color: #7fff00;">}</span>
    <span style="color: #ff1493;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9;">unimplemented!</span><span style="color: #7fff00;">()</span>
    <span style="color: #ff1493;">}</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
The tactic of the deleting node with <code>replace</code> allows us to get
ownership of the node that gives us ownership of the value we want
to return. Since a child tree was promoted, no height or rebalancing
is needed for the replaced node.
</p>

<p>
With the one child node, we can get a node and replace the deleted
node with that. With no children, we cannot use the same tactic.
Instead, we have to go the parent node and delete if from there:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff8c00;">(</span>left_node<span style="color: #ff8c00;">)</span> = target_node.left.take<span style="color: #ff8c00;">()</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>
<span style="color: #ff8c00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff8c00;">(</span>right_node<span style="color: #ff8c00;">)</span> = target_node.right.take<span style="color: #ff8c00;">()</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>
<span style="color: #ff8c00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1a. Get parent node</span>
    <span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>prev_ptr<span style="color: #ff1493;">)</span> = prev_ptrs.pop<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">prev_node</span> = <span style="color: #f5b55f; text-decoration: underline;">unsafe</span> <span style="color: #7fff00;">{</span> &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> *prev_ptr <span style="color: #7fff00;">}</span>;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1b. Determine which node to remove: left or right node</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">inner_value</span> = <span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span><span style="color: #96a5d9; font-weight: bold;">ref</span> <span style="color: #ff694d;">left_node</span><span style="color: #7fff00;">)</span> = prev_node.left <span style="color: #7fff00;">{</span>
            <span style="color: #96a5d9; font-weight: bold;">if</span> left_node.value == target_node.value <span style="color: #00bfff;">{</span>
                prev_node.left.take<span style="color: #ffff00;">()</span>.unwrap<span style="color: #ffff00;">()</span>.value
            <span style="color: #00bfff;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #00bfff;">{</span>
                prev_node.right.take<span style="color: #ffff00;">()</span>.unwrap<span style="color: #ffff00;">()</span>.value
            <span style="color: #00bfff;">}</span>
        <span style="color: #7fff00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #7fff00;">{</span>
            prev_node.right.take<span style="color: #00bfff;">()</span>.unwrap<span style="color: #00bfff;">()</span>.value
        <span style="color: #7fff00;">}</span>;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">2. Update parent node</span>
        prev_node.update_height<span style="color: #7fff00;">()</span>;
        prev_node.rebalance<span style="color: #7fff00;">()</span>;

        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">3. Return value</span>
        inner_value
    <span style="color: #ff1493;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #ff1493;">{</span>
        <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1c. ... otherwise it is the parent and take the root node</span>
        <span style="color: #96a5d9; font-weight: bold;">self</span>.root.take<span style="color: #7fff00;">()</span>.unwrap<span style="color: #7fff00;">()</span>.value
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Given the parent node, we determine which left or right node to take
by checking for equality once again. We could create an extra enum or
flag to remember the path, but it is a minor trade-off than adding
state. Either way, we take that node and returns its value; however,
since the parent node had a child removed, we update it accordingly.
Lastly, it is possible no previous nodes were traversed that implies
it is an isolated root node to delete which is easily handled.
Another case where pattern matching helps with illuminating edge
cases. With some confidence in our reasoning, we handle the hard case
of two children.
</p>
</div>
</div>

<div id="outline-container-org73303ed" class="outline-3">
<h3 id="org73303ed">Two Children</h3>
<div class="outline-text-3" id="text-org73303ed">
<p>
For two children, we replace the deleted node with the node of the
next value or the leftmost child of the right child of the deleted
node:
</p>

<p>
<img src="./Understanding_Rust_Through_AVL_Trees_files/avl-trees--node-deletion.jpg" alt="Visualization of Node Deletion">
</p>

<p>
Describing the algorithm:
</p>

<ol class="org-ol">
<li>Starting with the right child of the target node</li>
<li>Keep moving the current node to the left child until it has none</li>
<li>Replace the target node value with the current node value</li>
<li>Replace the current node with the right child if it has one</li>
</ol>

<p>
Applying all the prior techniques for this final challenge:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">taken_value</span> = <span style="color: #96a5d9; font-weight: bold;">if</span> target_node.left.is_none<span style="color: #ff8c00;">()</span> || target_node.right.is_none<span style="color: #ff8c00;">()</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>
<span style="color: #ff8c00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">right_tree</span> = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> target_node.right;

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">1. Starting with the right child of the target node</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">next_tree</span> = right_tree;
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">We also keep track of the parent nodes to update the height</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">inner_ptrs</span> = <span style="color: #f5b55f;">Vec</span>::<span style="color: #ff1493;">&lt;</span>*<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">AvlNode</span><span style="color: #7fff00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;</span>::new<span style="color: #ff1493;">()</span>;

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">2. Keep moving the current node to the left child until it has none</span>
    <span style="color: #96a5d9; font-weight: bold;">while</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff1493;">(</span>next_left_node<span style="color: #ff1493;">)</span> = next_tree <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">if</span> next_left_node.left.is_some<span style="color: #7fff00;">()</span> <span style="color: #7fff00;">{</span>
            inner_ptrs.push<span style="color: #00bfff;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> **next_left_node<span style="color: #00bfff;">)</span>;
        <span style="color: #7fff00;">}</span>
        next_tree = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> next_left_node.left;
    <span style="color: #ff1493;">}</span>

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">We don't use next_tree but instead the tracked nodes as basis</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">parent_left_node</span> = <span style="color: #f5b55f; text-decoration: underline;">unsafe</span> <span style="color: #ff1493;">{</span> &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> *inner_ptrs.pop<span style="color: #7fff00;">()</span>.unwrap<span style="color: #7fff00;">()</span> <span style="color: #ff1493;">}</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">leftmost_node</span> = parent_left_node.left.take<span style="color: #ff1493;">()</span>.unwrap<span style="color: #ff1493;">()</span>;

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">3. Replace the target node value with the current node value</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">inner_value</span> = replace<span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> target_node.value, leftmost_node.value<span style="color: #ff1493;">)</span>;
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">4. Replace the current node with the right child if it has</span>
    replace<span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> parent_left_node.left, leftmost_node.right.take<span style="color: #7fff00;">()</span><span style="color: #ff1493;">)</span>;

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Updates the nodes in order</span>
    parent_left_node.update_height<span style="color: #ff1493;">()</span>;
    parent_left_node.rebalance<span style="color: #ff1493;">()</span>;

    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">node_ptr</span> <span style="color: #96a5d9; font-weight: bold;">in</span> inner_ptrs.into_iter<span style="color: #ff1493;">()</span>.rev<span style="color: #ff1493;">()</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">node</span> = <span style="color: #f5b55f; text-decoration: underline;">unsafe</span> <span style="color: #7fff00;">{</span> &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> *node_ptr <span style="color: #7fff00;">}</span>;
        node.update_height<span style="color: #7fff00;">()</span>;
        node.rebalance<span style="color: #7fff00;">()</span>;
    <span style="color: #ff1493;">}</span>

    target_node.update_height<span style="color: #ff1493;">()</span>;
    target_node.rebalance<span style="color: #ff1493;">()</span>;

    inner_value
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
It is quite a mouthful and the last bit of complex code. It is like
an inner delete based on the child right tree that follows the same
conventions. After promoting a bottom node, we have an interesting
path of nodes to update and balance: the parent of the leftmost child
up to the originating target node. Stepping through the code should
be straightforward although more complex.
</p>

<p>
For the astute reader, we have one final edge case as the code above
assumes that at least one tracked node always exist by the
declaration of <code>parent_left_node</code> that only happens when the direct
right node has no left child based on the diagram. In that simpler
yet similar case, we replace that node with the right child if has
any:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">right_tree</span> = &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> target_node.right;

<span style="color: #96a5d9; font-weight: bold;">if</span> right_tree.as_ref<span style="color: #ff8c00;">()</span>.unwrap<span style="color: #ff8c00;">()</span>.left.is_none<span style="color: #ff8c00;">()</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">right_node</span> = right_tree.take<span style="color: #ff1493;">()</span>.unwrap<span style="color: #ff1493;">()</span>;

    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">inner_value</span> = replace<span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> target_node.value, right_node.value<span style="color: #ff1493;">)</span>;
    replace<span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> target_node.right, right_node.right.take<span style="color: #7fff00;">()</span><span style="color: #ff1493;">)</span>;

    target_node.update_height<span style="color: #ff1493;">()</span>;
    target_node.rebalance<span style="color: #ff1493;">()</span>;

    inner_value
<span style="color: #ff8c00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Previous case</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
With that final edge case, the <code>.take</code> method is complete and ready
to test.
</p>
</div>
</div>

<div id="outline-container-orgd1d4e25" class="outline-3">
<h3 id="orgd1d4e25">Deletion Testing</h3>
<div class="outline-text-3" id="text-orgd1d4e25">
<p>
To test deletion, we need to test for existence that we do by
finally implementing a <a href="https://doc.rust-lang.org/std/collections/btree_set/struct.BTreeSet.html#method.contains">BTreeSet::contains</a> method. With everything
done so far, this is a relief:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">impl</span><span style="color: #ff8c00;">&lt;</span>'<span style="color: #ff694d;">a</span>, <span style="color: #ff694d;">T</span>: '<span style="color: #ff694d;">a</span> + <span style="color: #f5b55f;">Ord</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #ff8c00;">&lt;</span><span style="color: #f5b55f;">T</span><span style="color: #ff8c00;">&gt;</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">pub</span> <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">contains</span><span style="color: #ff1493;">(</span>&amp;<span style="color: #96a5d9; font-weight: bold;">self</span>, <span style="color: #ff694d;">value</span>: &amp;<span style="color: #f5b55f;">T</span><span style="color: #ff1493;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">current_tree</span> = &amp;<span style="color: #96a5d9; font-weight: bold;">self</span>.root;

        <span style="color: #96a5d9; font-weight: bold;">while</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #7fff00;">(</span>current_node<span style="color: #7fff00;">)</span> = current_tree <span style="color: #7fff00;">{</span>
            <span style="color: #96a5d9; font-weight: bold;">match</span> current_node.value.cmp<span style="color: #00bfff;">(</span>&amp;value<span style="color: #00bfff;">)</span> <span style="color: #00bfff;">{</span>
                <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Less</span> =&gt; <span style="color: #ffff00;">{</span>
                    current_tree = &amp;current_node.right;
                <span style="color: #ffff00;">}</span>
                <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Equal</span> =&gt; <span style="color: #ffff00;">{</span>
                    <span style="color: #96a5d9; font-weight: bold;">return</span> <span style="color: #96a5d9; font-weight: bold;">true</span>;
                <span style="color: #ffff00;">}</span>
                <span style="color: #f5b55f;">Ordering</span>::<span style="color: #f5b55f;">Greater</span> =&gt; <span style="color: #ffff00;">{</span>
                    current_tree = &amp;current_node.left;
                <span style="color: #ffff00;">}</span>
            <span style="color: #00bfff;">}</span>;
        <span style="color: #7fff00;">}</span>

        <span style="color: #96a5d9; font-weight: bold;">false</span>
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
<b>Given an equal AVL and BTree set, <code>.contains</code> should be the same
for every value</b>. Testing <code>.contains</code> will have a little twist. We
want to have a more defined positive and negative test cases, so when
cloning a list of numbers, we only include the even numbers as
positive cases and odd as negatives:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">contains_parity</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">xs</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">isize</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">evens</span> = xs
        .iter<span style="color: #ff1493;">()</span>
        .cloned<span style="color: #ff1493;">()</span>
        .filter<span style="color: #ff1493;">(</span>|x| x % 2 == 0<span style="color: #ff1493;">)</span>
        .collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">avl_set</span> = evens.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">btree_set</span> = evens.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">BTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    all<span style="color: #ff1493;">(</span>xs.iter<span style="color: #7fff00;">()</span>, |x| avl_set.contains<span style="color: #7fff00;">(</span>x<span style="color: #7fff00;">)</span> == btree_set.contains<span style="color: #7fff00;">(</span>x<span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
As long as we have a subset of data, it is valid. Also we do not need
to filter test cases so we revert back to the familiar test template.
Assuming the test works, we use the same template of positive and
negative testing for <code>.take</code> as well. Thanks to the previous
sections, we establish our tree has three core properties:
</p>

<ol class="org-ol">
<li>Ordering</li>
<li>Height</li>
<li>Balanced</li>
</ol>

<p>
If we prove that each property holds after several deletions, it
shows our tree is balanced and correct. Writing a separate test for
each one might be more verbose, but it makes failing properties
easier to reason about.
</p>

<p>
<b>Given an equal AVL and BTree set, <code>.take</code> should be the same for
every value</b>. Before we check the core properties, we test if the
interface is correct:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">take_parity</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">xs</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">usize</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">odds</span> = xs
        .iter<span style="color: #ff1493;">()</span>
        .cloned<span style="color: #ff1493;">()</span>
        .filter<span style="color: #ff1493;">(</span>|x| x % 2 == 1<span style="color: #ff1493;">)</span>
        .collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">avl_set</span> = odds.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">btree_set</span> = odds.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">BTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    all<span style="color: #ff1493;">(</span>xs.iter<span style="color: #7fff00;">()</span>, |x| avl_set.take<span style="color: #7fff00;">(</span>x<span style="color: #7fff00;">)</span> == btree_set.take<span style="color: #7fff00;">(</span>x<span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>

</pre>
</div>

<p>
Establishing the methods are equal, we then test the first property
which is our comfortable iterator equality test.
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">take_iterator_parity</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">xs</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">i16</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">fives</span> = xs
        .iter<span style="color: #ff1493;">()</span>
        .cloned<span style="color: #ff1493;">()</span>
        .filter<span style="color: #ff1493;">(</span>|x| x % 5 == 0<span style="color: #ff1493;">)</span>
        .collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">avl_set</span> = xs.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">btree_set</span> = xs.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">BTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">five</span> <span style="color: #96a5d9; font-weight: bold;">in</span> fives <span style="color: #ff1493;">{</span>
        <span style="color: #96a5d9;">assert_eq!</span><span style="color: #7fff00;">(</span>avl_set.take<span style="color: #00bfff;">(</span>&amp;five<span style="color: #00bfff;">)</span>, btree_set.take<span style="color: #00bfff;">(</span>&amp;five<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>;
    <span style="color: #ff1493;">}</span>

    equal<span style="color: #ff1493;">(</span>avl_set.iter<span style="color: #7fff00;">()</span>, btree_set.iter<span style="color: #7fff00;">()</span><span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Aside from order, this guarantees our deletion does delete the
correct nodes and preserves the others. Next one is height via node
iterator:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">take_height_nodes</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">xs</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">isize</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">negatives</span> = xs.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.filter<span style="color: #ff1493;">(</span>|&amp;x| x &lt; 0<span style="color: #ff1493;">)</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = xs.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">negative</span> <span style="color: #96a5d9; font-weight: bold;">in</span> negatives <span style="color: #ff1493;">{</span>
        set.take<span style="color: #7fff00;">(</span>&amp;negative<span style="color: #7fff00;">)</span>;
    <span style="color: #ff1493;">}</span>

    all<span style="color: #ff1493;">(</span>set.node_iter<span style="color: #7fff00;">()</span>, |node| <span style="color: #7fff00;">{</span>
        node.height == 1 + max<span style="color: #00bfff;">(</span>node.left_height<span style="color: #ffff00;">()</span>, node.right_height<span style="color: #ffff00;">()</span><span style="color: #00bfff;">)</span>
    <span style="color: #7fff00;">}</span><span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Having correct heights is a good sign that nodes are updated
properly. Topping it off, the balance factor is checked with the same
mechanics:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">quickcheck</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">take_balanced_nodes</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">xs</span>: <span style="color: #f5b55f;">Vec</span><span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">usize</span><span style="color: #ff1493;">&gt;</span><span style="color: #ff8c00;">)</span> -&gt; <span style="color: #f5b55f;">bool</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #ff694d;">odds</span> = xs
        .iter<span style="color: #ff1493;">()</span>
        .cloned<span style="color: #ff1493;">()</span>
        .filter<span style="color: #ff1493;">(</span>|x| x % 2 == 1<span style="color: #ff1493;">)</span>
        .collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">Vec</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;n
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = xs.iter<span style="color: #ff1493;">()</span>.cloned<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">odd</span> <span style="color: #96a5d9; font-weight: bold;">in</span> odds <span style="color: #ff1493;">{</span>
        set.take<span style="color: #7fff00;">(</span>&amp;odd<span style="color: #7fff00;">)</span>;
    <span style="color: #ff1493;">}</span>

    all<span style="color: #ff1493;">(</span>set.node_iter<span style="color: #7fff00;">()</span>, |node| node.balance_factor<span style="color: #7fff00;">()</span>.abs<span style="color: #7fff00;">()</span> &lt; 2<span style="color: #ff1493;">)</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Running the tests one last time proves victorious:
</p>

<div class="org-src-container">
<pre class="src src-text">   Compiling avl_tree_set_rs v0.1.0 (/home/nobody/avl_tree_set_rs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.12s
     Running target/debug/deps/avl_tree_set_rs-551042db094327bb

running 4 tests
/* Passing previous tests */
test set::properties::take_height_nodes ... ok
test set::properties::take_balanced_nodes ... ok
test set::properties::take_iterator_parity ... ok
test set::properties::take_parity ... ok
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b87d2f" class="outline-3">
<h3 id="org4b87d2f">Reflection</h3>
<div class="outline-text-3" id="text-org4b87d2f">
<p>
Originally, I used <a href="https://github.com/rust-rspec/rspec">rspec</a> and <a href="https://github.com/cksac/fake-rs">fake-rs</a> as my testing strategy that gave
me a good quality test workflow. In writing this article, I moved to
<i>quickcheck</i> as a better paradigm to test abstract data structure.
Aside from being easier to write and iterate, porting my tests to
this paradigm gave me failing tests specially on this dangerous
method. That was a good catch that also gave me better and smaller
counterexamples to find the memory issues in my code.
</p>

<p>
Aside from property based testing against a memory issue, working on
deletion is not that technical or hard. The prior two sections have
trained me to implement the algorithm with no fuzz. I am at peace, I
am productive.
</p>
</div>
</div>
</div>

<div id="outline-container-org48d7f72" class="outline-2">
<h2 id="org48d7f72">Beyond Parity</h2>
<div class="outline-text-2" id="text-org48d7f72">
<p>
In this article, we are done with the major goals of our project.
During my spare time, I implemented every struct method (not traits)
from <code>BTreeSet</code> to <code>AvlTreeSet</code> as practice. While insertion and
deletion were the hardest methods, everything else was cakewalk, so
checkout the <a href="https://github.com/FrancisMurillo/avl_tree_set_rs">code repository</a> if completion piques your interest. This
optional section is about a few things I found interesting.
</p>

<ul class="org-ul">
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org5187177">Benchmark</a></li>
<li><a href="https://francismurillo.github.io/2019-07-31-Understanding-Rust-Through-AVL-Trees/#org778a2a0">Memory Safety</a></li>
</ul>
</div>

<div id="outline-container-org5187177" class="outline-3">
<h3 id="org5187177">Benchmark</h3>
<div class="outline-text-3" id="text-org5187177">
<p>
As a minor fancy, how does our implementation perform against the
standard library? Consulting a <a href="https://doc.rust-lang.org/1.16.0/book/benchmark-tests.html">benchmarking chapter</a>, we can benchmark
the insert operation by generating random numbers and timing it using
this shortened snippet:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">bench</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">setup_random_btree_set</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">b</span>: &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">Bencher</span><span style="color: #ff8c00;">)</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">rng</span> = thread_rng<span style="color: #ff1493;">()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = <span style="color: #f5b55f;">BTreeSet</span>::new<span style="color: #ff1493;">()</span>;

    b.iter<span style="color: #ff1493;">(</span>|| <span style="color: #7fff00;">{</span>
        set.insert<span style="color: #00bfff;">(</span>rng.gen::<span style="color: #ffff00;">&lt;</span><span style="color: #f5b55f;">usize</span><span style="color: #ffff00;">&gt;()</span><span style="color: #00bfff;">)</span>;
    <span style="color: #7fff00;">}</span><span style="color: #ff1493;">)</span>;
<span style="color: #ff8c00;">}</span>

<span style="color: #96a5d9;">#</span><span style="color: #ff8c00;">[</span><span style="color: #96a5d9;">bench</span><span style="color: #ff8c00;">]</span>
<span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">setup_random_avltree_set</span><span style="color: #ff8c00;">(</span><span style="color: #ff694d;">b</span>: &amp;<span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #f5b55f;">Bencher</span><span style="color: #ff8c00;">)</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">rng</span> = thread_rng<span style="color: #ff1493;">()</span>;
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = <span style="color: #f5b55f;">AvlTreeSet</span>::new<span style="color: #ff1493;">()</span>;

    b.iter<span style="color: #ff1493;">(</span>|| <span style="color: #7fff00;">{</span>
        set.insert<span style="color: #00bfff;">(</span>rng.gen::<span style="color: #ffff00;">&lt;</span><span style="color: #f5b55f;">usize</span><span style="color: #ffff00;">&gt;()</span><span style="color: #00bfff;">)</span>;
    <span style="color: #7fff00;">}</span><span style="color: #ff1493;">)</span>;
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Here, we use <a href="https://github.com/rust-random/rand">rand</a> crate to generate random numbers outside of
<i>quickcheck</i> to populate our set and the base set. We conveniently
have a builtin cargo <a href="https://doc.rust-lang.org/cargo/commands/cargo-bench.html">bench</a> command that works out of the box, so we
can just run <code>cargo bench</code> and watch:
</p>

<div class="org-src-container">
<pre class="src src-text">    Finished release [optimized] target(s) in 0.04s
     Running target/release/deps/avl_tree_set_rs-e74d4a8db1cacec9

running 17 tests
/* Passing prior tests */
test bench::setup_random_avltree_set ... bench:       1,800 ns/iter (+/- 517)
test bench::setup_random_btree_set   ... bench:         529 ns/iter (+/- 72)
</pre>
</div>

<p>
In this run, our toy set has insert performance that is more or less
four times slower than what <i>Rust</i> has matured. It would be strange
if it was significantly close. As simple as <code>.insert</code> is, the
bottleneck possibly lies in the rotations since they use many <code>.take</code>
or memory operations which could be further optimized. We now have a
general sense of relative performance for our implementation.
</p>
</div>
</div>

<div id="outline-container-org778a2a0" class="outline-3">
<h3 id="org778a2a0">Memory Safety</h3>
<div class="outline-text-3" id="text-org778a2a0">
<p>
Aside from the promise of safety, can we further prove our library
has no memory leaks? Asking this question lead me to <a href="https://creativcoder.github.io/post/checking_memory_leaks_in_rust_ffi/">this article</a> and
<a href="http://valgrind.org/">valgrind</a>: a memory error detector. Installing it and creating a small
main <code>bin.rs</code> file that generates a set and removes every element:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">use</span> <span style="color: #afc0fd; font-weight: bold;">avl_tree_set</span>::<span style="color: #afc0fd; font-weight: bold;">set</span>::<span style="color: #f5b55f;">AvlTreeSet</span>;

<span style="color: #96a5d9; font-weight: bold;">pub</span> <span style="color: #96a5d9; font-weight: bold;">fn</span> <span style="color: #bad6e2;">main</span><span style="color: #ff8c00;">()</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #96a5d9; font-weight: bold;">mut</span> <span style="color: #ff694d;">set</span> = <span style="color: #ff1493;">(</span>1..10_000 <span style="color: #96a5d9; font-weight: bold;">as</span> <span style="color: #f5b55f;">u32</span><span style="color: #ff1493;">)</span>.rev<span style="color: #ff1493;">()</span>.collect::<span style="color: #ff1493;">&lt;</span><span style="color: #f5b55f;">AvlTreeSet</span><span style="color: #7fff00;">&lt;</span>_<span style="color: #7fff00;">&gt;</span><span style="color: #ff1493;">&gt;()</span>;

    <span style="color: #96a5d9; font-weight: bold;">for</span> <span style="color: #ff694d;">i</span> <span style="color: #96a5d9; font-weight: bold;">in</span> 1..10_000 <span style="color: #ff1493;">{</span>
        set.take<span style="color: #7fff00;">(</span>&amp;i<span style="color: #7fff00;">)</span>;
    <span style="color: #ff1493;">}</span>
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Compiling it into an executable via <code>cargo build</code> and running
<code>valgrind --leak-check=full ./target/debug/avl_tree_set</code>
</p>

<div class="org-src-container">
<pre class="src src-text">==25728== Memcheck, a memory error detector
==25728== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==25728== Using Valgrind-3.16.0.GIT and LibVEX; rerun with -h for copyright info
==25728== Command: ./target/debug/avl_tree_set
==25728==
==25728==
==25728== HEAP SUMMARY:
==25728==     in use at exit: 0 bytes in 0 blocks
==25728==   total heap usage: 101,389 allocs, 101,389 frees, 4,198,985 bytes allocated
==25728==
==25728== All heap blocks were freed -- no leaks are possible
==25728==
==25728== For lists of detected and suppressed errors, rerun with: -s
==25728== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</pre>
</div>

<p>
Having an external tool check our small executable reveals no memory
leaks that is comforting and assuring along with passing tests. With
the code before I started writing this article, I followed the same
steps above with passing tests, I ran into the following:
</p>

<div class="org-src-container">
<pre class="src src-sh">==<span style="color: #ff694d;">3010</span>== Memcheck, a memory error detector
==<span style="color: #ff694d;">3010</span>== Copyright <span style="color: #ff8c00;">(</span>C<span style="color: #ff8c00;">)</span> 2002-2017, and GNU GPL<span style="color: #68f6cb;">'d, by Julian Seward et al.</span>
<span style="color: #68f6cb;">==3010== Using Valgrind-3.16.0.GIT and LibVEX; rerun with -h for copyright info</span>
<span style="color: #68f6cb;">==3010== Command: ./target/debug/avl_tree_set</span>
<span style="color: #68f6cb;">==3010==</span>
<span style="color: #68f6cb;">==3010== Invalid read of size 8</span>
<span style="color: #68f6cb;">==3010==    at 0x1104BE: core::option::Option&lt;T&gt;::as_ref (option.rs:239)</span>
<span style="color: #68f6cb;">==3010==    by 0x10EF32: avl_tree_set::tree::AvlNode&lt;T&gt;::left_height (tree.rs:16)</span>
<span style="color: #68f6cb;">==3010==    by 0x10F942: avl_tree_set::tree::AvlNode&lt;T&gt;::update_height (tree.rs:24)</span>
<span style="color: #68f6cb;">==3010==    by 0x112ABA: avl_tree_set::set::AvlTreeSet&lt;T&gt;::take (set.rs:107)</span>
<span style="color: #68f6cb;">==3010==    by 0x11113A: avl_tree_set::main (bin.rs:7)</span>
<span style="color: #68f6cb;">==3010==    by 0x113E6F: std::rt::lang_start:: (rt.rs:64)</span>
<span style="color: #68f6cb;">==3010==    by 0x11A9B2:  (rt.rs:49)</span>
<span style="color: #68f6cb;">==3010==    by 0x11A9B2: std::panicking::try::do_call (panicking.rs:294)</span>
<span style="color: #68f6cb;">==3010==    by 0x11C319: __rust_maybe_catch_panic (lib.rs:82)</span>
<span style="color: #68f6cb;">/* More errors down below */</span>
</pre>
</div>

<p>
Conflicted with passing tests and a memory issue I could not
replicate in test, my denial thought that <code>valgrind</code> was broken
instead. Switching to property based test helped in finding test
cases that causes memory issues. The offending code happens with the
deletion of a leaf node in the old code:
</p>

<div class="org-src-container">
<pre class="src src-rust"><span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #96a5d9; font-weight: bold;">let</span> <span style="color: #f5b55f;">Some</span><span style="color: #ff8c00;">(</span>prev_ptr<span style="color: #ff8c00;">)</span> = prev_ptrs.pop<span style="color: #ff8c00;">()</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">snip</span>

    prev_node.update_height<span style="color: #ff1493;">()</span>;
    prev_node.rebalance<span style="color: #ff1493;">()</span>;

    <span style="color: #2872b2;">// </span><span style="color: #2872b2;">Memory issue</span>
    target_node.update_height<span style="color: #ff1493;">()</span>;
    target_node.rebalance<span style="color: #ff1493;">()</span>;

    inner_value
<span style="color: #ff8c00;">}</span> <span style="color: #96a5d9; font-weight: bold;">else</span> <span style="color: #ff8c00;">{</span>
    <span style="color: #96a5d9; font-weight: bold;">self</span>.root.take<span style="color: #ff1493;">()</span>.unwrap<span style="color: #ff1493;">()</span>.value
<span style="color: #ff8c00;">}</span>
</pre>
</div>

<p>
Recall in the no children case, we detach the <code>target_node</code> and
updated the <code>prev_node</code> instead. I forgot about that assumption and
carelessly updated the deleted node and remember that <code>prev_node</code>
comes from an <code>unsafe</code> pointer that breaks the single mutable
reference rule. Perhaps, <code>target_node</code> has a child that that was part
of the rotation and became a dangling pointer afterwards. Although
our use of <code>unsafe</code> was seemingly safe, my tests did not catch that.
As proud as I was of my old tests, having external tools offer
insights outside my ego and bias. So even when the code compiles and
passes, it is good to check running code.
</p>
</div>
</div>
</div>

<div id="outline-container-orgaa91b9a" class="outline-2">
<h2 id="orgaa91b9a">Reflecting On Rust</h2>
<div class="outline-text-2" id="text-orgaa91b9a">
<p>
Although not a shining example of <i>AVL Trees</i>, it has been a good
first project. I believe it was a good vertical slice of <i>Rust</i>. In
the beginning, understanding, patience and perseverance is required
with the new idioms and designs and specially for the compiler.
Working through the code, familiarizing new functions and traits and
grasping lifetimes were the only difficulty. Reflecting on its style,
it is a happy union/mix between object oriented and functional.
Overall, <i>Rust</i> is overall a challenging yet rewarding language with
little to complain syntactically.
</p>

<p>
Looking back on <i>Ruby</i> and <i>Elixir</i>, I frequently find myself looking
for the <code>&amp;</code> or borrow operator in the variables. Working with the
<i>Borrow Checker</i>, I believe, has been a positive experience although
rigorous. As such, I realize that this intricate mechanism cannot
easily be ported to other language without design considerations. If
<i>Elixir</i> had <i>Rust</i>'s mechanics, I doubt it would be as popular or as
ergonomic in its (almost) actor/process model. (Perhaps <a href="https://www.ponylang.io/">Pony language</a>
will be the evolved version when it matures?) As a modern observation,
languages that value a form application safety (memory, data,
correctness) tends to have higher learning curves and barriers to
entry because of the required mindset and philosophies. With <a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html">better
ergonomics</a>, documentation and tooling, the learning curve is somewhat
balanced. So despite its accessibility, <i>Rust</i> definitely deserves
attention and discussion for its rare core value of safety.
</p>

<p>
This was a long article to prepare and write, so thank you for making
it to the end. I hope you found the journey meaningful or valuable in
some way. What is the next learning project? Aside from reading <a href="https://doc.rust-lang.org/nomicon/borrow-splitting.html?highlight=Tree#splitting-borrows">The
Rustonomicon</a> first, here are some project ideas:
</p>

<dl class="org-dl">
<dt><b><a href="https://github.com/kanaka/mal">Make a Lisp</a> in Rust</b></dt><dd>Implementing a (LISP) language is a dream.</dd>
<dt><b>GraphQL Server</b></dt><dd>Is <i>Rust</i> good for the usual web development or microservices?</dd>
<dt><b>Web Scraping/Crawling</b></dt><dd>A good opportunity to learn asynchronous and concurrent operations.</dd>
<dt><b>C Interop</b></dt><dd>How good is the workflow in integrating with native libraries?</dd>
<dt><b>Web Assembly</b></dt><dd>A backend language in the browser is interesting</dd>
</dl>

<p>
As a newcomer, I am excited with the new doors <i>Rust</i> has opened for
me. For now, I feel ecstatic in writing a valid library that I am
confidently safer than it would be in <i>C</i>. That is good enough for me.
</p>
</div>
</div>

    </div>
</article>

      </div>
    </div>
    <footer class="echo-area">
    <p class="contact">
        Thanks for making it this far. If you want to say something to me, you can reach me in the following ways:
        <a class="external-link" href="mailto:francisavmurillo@gmail.com">Email</a> and
        <a class="external-link" href="https://github.com/FrancisMurillo">Github</a>,
        If find my content helpful and want to support me, you can donate through my
        <a class="external-link" href="https://www.patreon.com/user?u=3312725">Patreon</a>,
        <a class="external-link" href="https://liberapay.com/FrancisMurillo/donate">
            Liberapay
        </a>,
        or
        <a class="external-link" href="bitcoin:38UKeSuwHb2f6GL1ahgAyJ58n6L2oWSXSx">Bitcoin</a>
    </p>
    <p class="license">
        This work is licensed under a
        <a class="external-link" href="http://creativecommons.org/licenses/by/4.0/">Creative
          Commons Attribution 4.0 International License</a>.
      Images here are only visual aids which I did not create and belong
      to whoever they belong to.
  </p>
</footer>

  

</body></html>